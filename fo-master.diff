diff --git a/.gitignore b/.gitignore
index 2edd2b2..2b399c4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,8 +1,4 @@
 *.class
-*.iml
-*.iws
-*.ipr
-target/
 
 # Mobile Tools for Java (J2ME)
 .mtj.tmp/
@@ -14,3 +10,11 @@ target/
 
 # virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
 hs_err_pid*
+
+# Ignore everything in this directory
+target
+.classpath
+.settings
+.project
+*.i??
+.idea
diff --git a/LICENSE b/LICENSE
index 8f71f43..427c45f 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,202 +1,80 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "{}"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright {yyyy} {name of copyright owner}
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
 
+This product is licensed by WSO2 Inc. under Apache License 2.0. The license
+can be downloaded from the following locations:
+	http://www.apache.org/licenses/LICENSE-2.0.html
+	http://www.apache.org/licenses/LICENSE-2.0.txt
+
+This product also contains software under different licenses. This table below
+all the contained libraries (jar files) and the license under which they are 
+provided to you.
+
+At the bottom of this file is a table that shows what each license indicated
+below is and where the actual text of the license can be found.
+
+Name                                                                            Type           License   
+---------------------------------------------------------------------------------------------------------
+commons-pool_1.5.6.wso2v1.jar                                                   bundle         apache2   1009      
+disruptor_3.3.2.wso2v2.jar                                                      bundle         apache2   4377      
+io.netty.buffer_4.0.30.Final.jar                                                bundle         apache2   1544      
+io.netty.codec-http_4.0.30.Final.jar                                            bundle         apache2   1543      
+io.netty.codec_4.0.30.Final.jar                                                 bundle         apache2   1542      
+io.netty.common_4.0.30.Final.jar                                                bundle         apache2   1541      
+io.netty.handler_4.0.30.Final.jar                                               bundle         apache2   1540      
+io.netty.transport_4.0.30.Final.jar                                             bundle         apache2   1539      
+org.apache.camel.camel-core_2.15.2.jar                                          bundle         apache2   1546      
+org.apache.camel.camel-spring_2.15.2.jar                                        bundle         apache2   1545      
+org.apache.felix.gogo.command_0.10.0.v201209301215.jar                          bundle         apache2   1134      
+org.apache.felix.gogo.runtime_0.10.0.v201209301036.jar                          bundle         apache2   1133      
+org.apache.felix.gogo.shell_0.10.0.v201212101605.jar                            bundle         apache2   1132      
+org.eclipse.core.contenttype_3.4.200.v20140207-1251.jar                         bundle         epl1      1432      
+org.eclipse.core.expressions_3.4.600.v20140128-0851.jar                         bundle         epl1      1431      
+org.eclipse.core.jobs_3.6.1.v20141014-1248.jar                                  bundle         epl1      1430      
+org.eclipse.core.runtime_3.10.0.v20140318-2214.jar                              bundle         epl1      1429      
+org.eclipse.ecf.filetransfer_5.0.0.v20141221-2352.jar                           bundle         epl1      1428      
+org.eclipse.ecf.identity_3.4.0.v20141221-2352.jar                               bundle         epl1      1427      
+org.eclipse.ecf.provider.filetransfer_3.2.200.v20141221-2352.jar                bundle         epl1      1426      
+org.eclipse.ecf_3.4.0.v20141221-2352.jar                                        bundle         epl1      1425      
+org.eclipse.equinox.app_1.3.200.v20130910-1609.jar                              bundle         epl1      1424      
+org.eclipse.equinox.cm_1.1.0.v20131021-1936.jar                                 bundle         epl1      1423      
+org.eclipse.equinox.common_3.6.200.v20130402-1505.jar                           bundle         epl1      1122      
+org.eclipse.equinox.concurrent_1.1.0.v20130327-1442.jar                         bundle         epl1      1121      
+org.eclipse.equinox.console_1.1.0.v20140131-1639.jar                            bundle         epl1      1422      
+org.eclipse.equinox.ds_1.4.200.v20131126-2331.jar                               bundle         epl1      1421      
+org.eclipse.equinox.frameworkadmin.equinox_1.0.500.v20131211-1531.jar           bundle         epl1      1420      
+org.eclipse.equinox.frameworkadmin_2.0.100.v20131209-2144.jar                   bundle         epl1      1419      
+org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar                           bundle         epl1      1418      
+org.eclipse.equinox.preferences_3.5.200.v20140224-1527.jar                      bundle         epl1      1417      
+org.eclipse.equinox.registry_3.5.400.v20140428-1507.jar                         bundle         epl1      1416      
+org.eclipse.equinox.security_1.2.0.v20130424-1801.jar                           bundle         epl1      1097      
+org.eclipse.equinox.simpleconfigurator.manipulator_2.0.0.v20131217-1203.jar     bundle         epl1      1415      
+org.eclipse.equinox.simpleconfigurator_1.1.0.v20131217-1203.jar                 bundle         epl1      1414      
+org.eclipse.equinox.util_1.0.500.v20130404-1337.jar                             bundle         epl1      1094      
+org.eclipse.osgi.compatibility.state_1.0.1.v20140709-1414.jar                   bundle         epl1      1413      
+org.eclipse.osgi.services_3.4.0.v20140312-2051.jar                              bundle         epl1      1412      
+org.eclipse.osgi_3.10.2.v20150203-1939.jar                                      bundle         epl1      1411      
+org.ops4j.pax.logging.pax-logging-api_1.8.4.jar                                 bundle         apache2   1410      
+org.ops4j.pax.logging.pax-logging-log4j2_1.8.4.jar                              bundle         apache2   1409      
+org.osgi.core-6.0.0.jar                                                         bundle         apache2   1407      
+org.sat4j.core_2.3.5.v201308161310.jar                                          bundle         epl1+lgpl21091      
+org.sat4j.pb_2.3.5.v201404071733.jar                                            bundle         apache2   1408      
+org.wso2.carbon.core_5.0.0.alpha.jar                                            bundle         apache2   6039      
+org.wso2.carbon.gateway_1.0.0.alpha.jar                                         bundle         apache2   6041
+org.wso2.carbon.launcher-5.0.0-alpha.jar                                        bundle         apache2   6036      
+org.wso2.carbon.tools-5.0.0-alpha.jar                                           bundle         apache2   6035      
+org.wso2.carbon.transport.http.netty_1.0.0.alpha.jar                            bundle         apache2   6037      
+slf4j.api_1.7.5.jar                                                             bundle         mit       794       
+slf4j.log4j12_1.7.5.jar                                                         bundle         mit       1211      
+spring.framework_4.1.6.wso2v1.jar                                               bundle         apache2   6040      
+
+
+
+The license types used by the above libraries and their information is given below:
+
+apache2        Apache License Version 2.0
+               http://www.apache.org/licenses/LICENSE-2.0.html
+mit            MIT License
+               http://www.opensource.org/licenses/mit-license.php
+epl1+lgpl2     EPL1 + LGPL2
+               http://www.eclipse.org/legal/epl-v10.html + http://www.gnu.org/licenses/licenses.html
+epl1           Eclipse Public License
+               http://www.eclipse.org/legal/epl-v10.html
\ No newline at end of file
diff --git a/README.md b/README.md
index 0f26005..2b0b5c6 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,85 @@
-# product-gw
+#WSO2 Gateway (WSO2 GW)
+WSO2 Gateway (WSO2 GW) is an ultra high performance, lightweight and configuration-driven message gateway based on
+standard gateway pattern. It aims to encapsulate messaging between source and target systems that are built with
+disparate technologies, protocols, and standards. While it includes messaging between two systems, message mediation
+can be controlled by configuring WSO2 GW’s mediation logic.
+
+
+##Key Features
+
+* Ultra high performance and low latency  HTTP/S messaging.
+
+* Supports thousands of concurrent connections/clients.
+
+* Header-based routing using Apache Camel as the message mediation engine.
+
+* Defines REST services/APIs using Camel REST DSL.
+
+* Lightweight and stateless service orchestration.
+
+* Load balancing and failover messaging.
+
+* Error handling support. 
+
+##Getting Started
+
+By configuring the [camel-context.xml](https://github.com/wso2/product-gw/blob/master/product/carbon-home/repository/conf/camel/camel-context.xml) (which can be found in `$CARBON_HOME/repository/conf/camel/camel-context.xml`)
+we can achieve camel routing.
+
+####Sample camel configuration for Header-based routing
+```
+    <route id="http-routes">
+        <from uri="wso2-gw:/default"/>
+        <choice>
+            <when>
+                <simple>${header.routeId} regex 'r1'</simple>
+                <to uri="wso2-gw:http://localhost:9000/services/SimpleStockQuoteService"/>
+            </when>
+            <when>
+                <simple>${header.routeId} regex 'r2'</simple>
+                <to uri="wso2-gw:http://localhost:9002/service/SimpleStockQuoteService"/>
+            </when>
+            <otherwise>
+                <to uri="wso2-gw:http://localhost:9004/SimpleStockQuoteService"/>
+            </otherwise>
+        </choice>
+    </route>
+```
+
+ Sample request to route to localhost:9000
+ curl  http://localhost:9090/default -H __"routeId:r1"__
+
+ If we don't have any routeId header the request will be routed to the localhost:9004 (i.e to otherwise)
+
+####Sampel REST configuration
+
+Following is a sample rest interface definition
+```
+    <rest path="/gw">
+        <get uri="/news">
+            <to uri="direct:getNews"/>
+        </get>
+        <get uri="/news/{id}">
+            <to uri="direct:getNewsById"/>
+        </get>
+    </rest>
+```
+
+and follwoing is the corresponding routes
+```
+    <route>
+        <from uri="direct:getNews"/>
+        <to uri="wso2-gw:http://jsonplaceholder.typicode.com/posts"/>
+    </route>
+    <route>
+        <from uri="direct:getNewsById"/>
+        <recipientList>
+            <simple>wso2-gw:http://jsonplaceholder.typicode.com/posts/${header.id}</simple>
+        </recipientList>
+    </route>
+```
+
+when we invoke the request `http://localhost:9090/gw/news`
+it will be routed to `http://jsonplaceholder.typicode.com/posts`
+
+similarly `http://localhost:9090/gw/news/24` will be routed to `http://jsonplaceholder.typicode.com/posts/24`
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/pom.xml b/carbon-gw/components/org.wso2.carbon.gateway/pom.xml
index da19c45..749450c 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/pom.xml
+++ b/carbon-gw/components/org.wso2.carbon.gateway/pom.xml
@@ -16,13 +16,11 @@
   ~ * limitations under the License.
   ~ */
   -->
-<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xmlns="http://maven.apache.org/POM/4.0.0"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>org.wso2.carbon</groupId>
+        <groupId>org.wso2.carbon.gateway</groupId>
         <artifactId>org.wso2.carbon.gateway.parent</artifactId>
         <version>1.0.0-SNAPSHOT</version>
         <relativePath>../../../pom.xml</relativePath>
@@ -51,12 +49,6 @@
         </developer>
     </developers>
 
-    <scm>
-        <connection>scm:git:git@github.com:caskdata/netty-http.git</connection>
-        <url>scm:git:git://github.com/wso2/product-gw.git</url>
-        <developerConnection>scm:git:git@github.com:wso2/product-gw.git</developerConnection>
-    </scm>
-
     <distributionManagement>
         <repository>
             <id>sonatype.release</id>
@@ -226,7 +218,7 @@
                                 org.osgi.framework.*;version="${osgi.framework.import.version.range}",
                                 org.osgi.util.tracker; version="${osgi.service.tracker.import.version.range}",
                                 io.netty.*,
-                                org.wso2.carbon.transports.*,
+                                org.wso2.carbon.kernel.transports.*,
                                 org.wso2.carbon.transport.http.netty.*,
                                 org.apache.log4j.*,
                                 org.apache.commons.logging.*,
@@ -234,9 +226,6 @@
                                 org.apache.commons.pool.*,
                                 com.lmax.disruptor.*,
                                 org.springframework.context.*,
-                                org.w3c.dom.*,
-                                org.xml.sax.*,
-                                javax.xml.*,
                                 org.slf4j.*
                             </Import-Package>
                             <_dsannotations>*</_dsannotations>
@@ -436,11 +425,6 @@
                         <artifactId>maven-gpg-plugin</artifactId>
                         <version>1.5</version>
                     </plugin>
-                    <plugin>
-                        <groupId>org.sonatype.plugins</groupId>
-                        <artifactId>nexus-staging-maven-plugin</artifactId>
-                        <version>1.6.2</version>
-                    </plugin>
                 </plugins>
             </build>
         </profile>
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/DataHolder.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/DataHolder.java
new file mode 100644
index 0000000..f7f4412
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/DataHolder.java
@@ -0,0 +1,73 @@
+/*
+ *  Copyright (c) 2005-2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+ *
+ *  WSO2 Inc. licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *
+ */
+package org.wso2.carbon.gateway.internal;
+
+import org.apache.log4j.Logger;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceRegistration;
+import org.wso2.carbon.gateway.internal.transport.listener.GatewayNettyInitializer;
+import org.wso2.carbon.kernel.transports.CarbonTransport;
+import org.wso2.carbon.transport.http.netty.listener.CarbonNettyServerInitializer;
+
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Map;
+
+/**
+ * DataHolder for the Gateway.
+ */
+public class DataHolder {
+    private static final Logger log = Logger.getLogger(DataHolder.class);
+
+    private static final String CHANNEL_ID_KEY = "channel.id";
+
+    private static DataHolder instance = new DataHolder();
+    private BundleContext bundleContext;
+    private Map<String, ServiceRegistration<CarbonNettyServerInitializer>> carbonTransports = new HashMap<>();
+
+    private DataHolder() {
+    }
+
+    public static DataHolder getInstance() {
+        return instance;
+    }
+
+    public void setBundleContext(BundleContext bundleContext) {
+        this.bundleContext = bundleContext;
+    }
+
+    public void addCarbonTransport(CarbonTransport carbonTransport) {
+        if (bundleContext == null) {
+            log.fatal("BundleContext is null. Transport dispatching will fail.");
+            return;
+        }
+        String channelKey = carbonTransport.getId();
+        Hashtable<String, String> httpInitParams = new Hashtable<>();
+        httpInitParams.put(CHANNEL_ID_KEY, channelKey);
+        GatewayNettyInitializer gatewayNettyInitializer = new GatewayNettyInitializer();
+        ServiceRegistration<CarbonNettyServerInitializer> service =
+                bundleContext.registerService(CarbonNettyServerInitializer.class,
+                        gatewayNettyInitializer, httpInitParams);
+        carbonTransports.put(channelKey, service);
+    }
+
+    public void removeCarbonTransport(CarbonTransport carbonTransport) {
+        carbonTransports.get(carbonTransport.getId()).unregister();
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/GatewayActivator.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/GatewayActivator.java
index e391d78..f6b5278 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/GatewayActivator.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/GatewayActivator.java
@@ -17,27 +17,17 @@ package org.wso2.carbon.gateway.internal;
 
 import org.osgi.framework.BundleActivator;
 import org.osgi.framework.BundleContext;
-import org.wso2.carbon.gateway.internal.transport.listener.GatewayNettyInitializer;
-import org.wso2.carbon.transport.http.netty.listener.CarbonNettyServerInitializer;
-
-import java.util.Hashtable;
 
 /**
  * OSGi Bundle Activator of the gateway Carbon component.
  */
 public class GatewayActivator implements BundleActivator {
-    private static final String CHANNEL_ID_KEY = "channel.id";
 
     public void start(BundleContext bundleContext) throws Exception {
-        Hashtable<String, String> httpInitParams = new Hashtable<>();
-        httpInitParams.put(CHANNEL_ID_KEY, "netty-gw");
-        GatewayNettyInitializer gatewayNettyInitializer = new GatewayNettyInitializer();
-        bundleContext.registerService(CarbonNettyServerInitializer.class, gatewayNettyInitializer, httpInitParams);
+        DataHolder.getInstance().setBundleContext(bundleContext);
     }
 
     public void stop(BundleContext bundleContext) throws Exception {
 
     }
-
 }
-
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/GatewayServiceComponent.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/GatewayServiceComponent.java
new file mode 100644
index 0000000..c92757f
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/GatewayServiceComponent.java
@@ -0,0 +1,51 @@
+/*
+ *  Copyright (c) 2005-2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+ *
+ *  WSO2 Inc. licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *
+ */
+package org.wso2.carbon.gateway.internal;
+
+import org.osgi.service.component.annotations.Component;
+import org.osgi.service.component.annotations.Reference;
+import org.osgi.service.component.annotations.ReferenceCardinality;
+import org.osgi.service.component.annotations.ReferencePolicy;
+import org.wso2.carbon.kernel.transports.CarbonTransport;
+
+/**
+ * OSGi service component for Gateway.
+ */
+@Component(
+        name = "org.wso2.carbon.gateway.internal.GatewayServiceComponent",
+        immediate = true
+)
+@SuppressWarnings("unused")
+public class GatewayServiceComponent {
+
+    @Reference(
+            name = "carbon-transport",
+            service = CarbonTransport.class,
+            cardinality = ReferenceCardinality.AT_LEAST_ONE,
+            policy = ReferencePolicy.DYNAMIC,
+            unbind = "removeCarbonTransport"
+    )
+    protected void addCarbonTransport(CarbonTransport carbonTransport) {
+        DataHolder.getInstance().addCarbonTransport(carbonTransport);
+    }
+
+    protected void removeCarbonTransport(CarbonTransport carbonTransport) {
+        DataHolder.getInstance().removeCarbonTransport(carbonTransport);
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonCallback.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonCallback.java
index ea2d7f7..5a064fc 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonCallback.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonCallback.java
@@ -17,14 +17,14 @@ package org.wso2.carbon.gateway.internal.common;
 
 /**
  * Callbacks are created in request path for execute in response path.
- * When response arrives callback methods should execute
- */
+ * When response arrives callback methods should execute.
+ *
+ * */
 public interface CarbonCallback {
 
     /**
-     * Calls in response path   to do work for response
-     *
-     * @param cMsg CarbonMessage to be processed
+     * Calls in response path   to do work for response.
+     * @param cMsg CarbonMessage to be processed.
      */
     void done(CarbonMessage cMsg);
 
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonException.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonException.java
deleted file mode 100644
index 575fa9c..0000000
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonException.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and limitations under the License.
- */
-
-package org.wso2.carbon.gateway.internal.common;
-
-/**
- * Custom exception class for gateway specific exceptions
- */
-public class CarbonException extends Exception {
-
-    public CarbonException() {
-    }
-
-    public CarbonException(String message) {
-        super(message);
-    }
-
-    public CarbonException(Throwable cause) {
-        super(cause);
-    }
-
-    public CarbonException(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonGatewayConstants.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonGatewayConstants.java
deleted file mode 100644
index c1c2eaf..0000000
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonGatewayConstants.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and limitations under the License.
- */
-package org.wso2.carbon.gateway.internal.common;
-
-/**
- * Class to keep the contants required for gateway implementation
- */
-public class CarbonGatewayConstants {
-    public static final String ORIGINAL_MESSAGE = "ORIGINAL_MESSAGE";
-    public static final int AGGREGATED_HTTP_MESSAGE_MAX_SIZE = 1048576;
-}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonMessage.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonMessage.java
index 3b94d5c..d4684f4 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonMessage.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonMessage.java
@@ -22,7 +22,7 @@ import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * Represents a  common message for all the transports and message processors. Canonical Format for represent
- * abstract message
+ * abstract message.
  */
 public class CarbonMessage {
     public static final int REQUEST = 0;
@@ -36,7 +36,7 @@ public class CarbonMessage {
 
     private CarbonCallback carbonCallback;
 
-    private String simplePayload;
+
 
     private int direction;
 
@@ -119,13 +119,4 @@ public class CarbonMessage {
         return lock;
     }
 
-
-    public String getSimplePayload() {
-        return simplePayload;
-    }
-
-    public void setSimplePayload(String simplePayload) {
-        this.simplePayload = simplePayload;
-    }
-
 }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonMessageProcessor.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonMessageProcessor.java
index 44569dc..e4a90da 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonMessageProcessor.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/CarbonMessageProcessor.java
@@ -21,10 +21,11 @@ package org.wso2.carbon.gateway.internal.common;
 public interface CarbonMessageProcessor {
 
     /**
-     * @param msg      CarbopnMessage received for processing
+     *
+     * @param msg CarbopnMessage received for processing.
      * @param callback Callback recived from transport layer to the engine.
      * @return void
-     * @throws Exception
+     * @throws Exception Exception to signal any failure at the message processor.
      */
     boolean receive(CarbonMessage msg, CarbonCallback callback) throws Exception;
 
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/GWException.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/GWException.java
new file mode 100644
index 0000000..8072cf5
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/GWException.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and limitations under the License.
+ */
+
+package org.wso2.carbon.gateway.internal.common;
+
+/**
+ * Custom exception class for gateway specific exceptions.
+ */
+public class GWException extends Exception {
+
+    public GWException() {
+    }
+
+    public GWException(String message) {
+        super(message);
+    }
+
+    public GWException(Throwable cause) {
+        super(cause);
+    }
+
+    public GWException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/Pipe.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/Pipe.java
index 53e41e9..eb83e54 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/Pipe.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/Pipe.java
@@ -15,8 +15,6 @@
 
 package org.wso2.carbon.gateway.internal.common;
 
-import java.util.concurrent.BlockingQueue;
-
 /**
  * Interface for create Content Holders.
  */
@@ -26,6 +24,4 @@ public interface Pipe {
 
     void addContentChunk(ContentChunk chunk);
 
-    BlockingQueue<ContentChunk> getClonedContentQueue();
-
 }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/TransportSender.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/TransportSender.java
index edf8e4a..ef692f1 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/TransportSender.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/common/TransportSender.java
@@ -13,21 +13,19 @@
  * See the License for the specific language governing permissions and limitations under the License.
  */
 
-
 package org.wso2.carbon.gateway.internal.common;
 
-
 /**
- * Interface for Message Sender to the BE
+ * Interface for Message Sender to the BE.
  */
 public interface TransportSender {
     /**
-     * Should include the logic for handover messages to BE
-     *
-     * @param msg      Mediated Request
-     * @param callback Carbon callback created by engine
+     * Should include the logic for handover messages to BE.
+     * @param msg Mediated Request.
+     * @param callback Carbon callback created by engine.
      * @return void
+     * @throws GWException Gateway exception to singal any failures to upper layers.
      */
-    public boolean send (CarbonMessage msg, CarbonCallback callback) throws CarbonException;
+    public boolean send(CarbonMessage msg, CarbonCallback callback) throws GWException;
 
 }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelHttp4Message.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelHttp4Message.java
deleted file mode 100644
index 1cecdab..0000000
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelHttp4Message.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and limitations under the License.
- */
-
-package org.wso2.carbon.gateway.internal.mediation.camel;
-
-import org.apache.camel.impl.DefaultMessage;
-import org.wso2.carbon.gateway.internal.common.CarbonMessage;
-
-/**
- * Wrapper class which represents the camel message to the mediation engine
- */
-public class CamelHttp4Message extends DefaultMessage {
-
-
-    private CarbonMessage carbonMessage;
-
-    public CarbonMessage getCarbonMessage() {
-        return this.carbonMessage;
-    }
-
-    public void setCarbonMessage(CarbonMessage carbonMessage) {
-        this.carbonMessage = carbonMessage;
-    }
-
-    @Override
-    public DefaultMessage newInstance() {
-        return new CamelHttp4Message();
-    }
-
-    @Override
-    public String toString() {
-        if (carbonMessage != null) {
-            return "CarbonMessage: " + carbonMessage;
-        } else {
-            return "CarbonMessage: " + getBody();
-        }
-    }
-
-    @Override
-    protected Object createBody() {
-        return this.carbonMessage;
-    }
-
-}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationComponent.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationComponent.java
index 12446b6..c9a42a7 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationComponent.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationComponent.java
@@ -31,6 +31,7 @@ import org.wso2.carbon.gateway.internal.common.TransportSender;
 import org.wso2.carbon.gateway.internal.transport.sender.NettySender;
 import org.wso2.carbon.gateway.internal.transport.sender.channel.pool.ConnectionManager;
 
+import java.util.Locale;
 import java.util.Map;
 
 /**
@@ -61,7 +62,7 @@ public class CamelMediationComponent extends DefaultComponent implements RestCon
             Object> parameters) throws Exception {
         String scheme = "http";
 
-        String url = "wso2-gw:%s://%s:%s/%s";
+        String url = "wso2-gw:%s://%s:%s/%s?httpMethodRestrict=%s";
         String host = HostUtils.getLocalHostName();
         int port = 0;
 
@@ -91,7 +92,9 @@ public class CamelMediationComponent extends DefaultComponent implements RestCon
         }
         path = FileUtil.stripLeadingSeparator(path);
 
-        url = String.format(url, scheme, host, port, path);
+        String restrict = verb.toUpperCase(Locale.US);
+
+        url = String.format(url, scheme, host, port, path, restrict);
 
         CamelMediationEndpoint camelMediationEndpoint = camelContext.getEndpoint(url, CamelMediationEndpoint.class);
         Consumer consumer = camelMediationEndpoint.createConsumer(processor);
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationConsumer.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationConsumer.java
index f994a32..f1c9eaa 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationConsumer.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationConsumer.java
@@ -23,8 +23,8 @@ import org.apache.camel.impl.DefaultConsumer;
 import org.apache.camel.util.ObjectHelper;
 
 /**
- * mediation starts from here : this is the camel mediation consumer
- * for each route a consumer is created and added to the engine consumers map
+ * mediation starts from here : this is the camel mediation consumer.
+ * for each route a consumer is created and added to the engine consumers map.
  */
 public class CamelMediationConsumer extends DefaultConsumer {
     private final CamelMediationEngine engine;
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationEndpoint.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationEndpoint.java
index 23ce13f..30b78d3 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationEndpoint.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationEndpoint.java
@@ -20,11 +20,9 @@ package org.wso2.carbon.gateway.internal.mediation.camel;
 
 import org.apache.camel.Consumer;
 import org.apache.camel.Exchange;
-import org.apache.camel.Message;
 import org.apache.camel.Processor;
 import org.apache.camel.Producer;
 import org.apache.camel.impl.DefaultEndpoint;
-import org.apache.log4j.Logger;
 import org.wso2.carbon.gateway.internal.common.CarbonMessage;
 
 import java.util.Map;
@@ -36,7 +34,7 @@ public class CamelMediationEndpoint extends DefaultEndpoint {
 
     private CamelMediationEngine engine;
     private CarbonCamelMessageUtil carbonCamelMessageUtil;
-    private static final Logger log = Logger.getLogger(CamelMediationEndpoint.class);
+    private String httpMethodRestrict;
 
     public CamelMediationEndpoint(String uri, CamelMediationComponent component, CamelMediationEngine engine) {
         super(uri, component);
@@ -52,31 +50,26 @@ public class CamelMediationEndpoint extends DefaultEndpoint {
         return new CamelMediationConsumer(this, processor, engine);
     }
 
+    public String getHttpMethodRestrict() {
+        return httpMethodRestrict;
+    }
+
+    public void setHttpMethodRestrict(String httpMethodRestrict) {
+        this.httpMethodRestrict = httpMethodRestrict;
+    }
+
+
     public boolean isSingleton() {
         return true;
     }
 
     public Exchange createExchange(Map<String, Object> headers, CarbonMessage cmsg) {
         Exchange exchange = createExchange();
-        try {
-            Message msg = createCamelMessage(cmsg, exchange);
-            exchange.setIn(msg);
-            carbonCamelMessageUtil.setCamelHeadersToClientRequest(exchange, headers, cmsg);
-        } catch (Exception e) {
-            log.error("Error occurred during the camel message creation", e);
-        }
-        //carbonCamelMessageUtil.setCamelHeadersToClientRequest(exchange, headers, cmsg);
-        //exchange.getIn().setBody(cmsg);
+        carbonCamelMessageUtil.setCamelHeadersToClientRequest(exchange, headers, cmsg);
+        exchange.getIn().setBody(cmsg);
         return exchange;
     }
 
-    public Message createCamelMessage(CarbonMessage carbonMessage, Exchange exchange) throws Exception {
-        CamelHttp4Message answer = new CamelHttp4Message();
-        answer.setCarbonMessage(carbonMessage);
-        answer.setExchange(exchange);
-        return answer;
-    }
-
     public CarbonCamelMessageUtil getCarbonCamelMessageUtil() {
         return carbonCamelMessageUtil;
     }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationEngine.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationEngine.java
index 31ca13a..6db0b29 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationEngine.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationEngine.java
@@ -18,6 +18,10 @@
 
 package org.wso2.carbon.gateway.internal.mediation.camel;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.http.DefaultLastHttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
 import org.apache.camel.Exchange;
 import org.apache.camel.ExchangePattern;
 import org.slf4j.Logger;
@@ -25,9 +29,18 @@ import org.slf4j.LoggerFactory;
 import org.wso2.carbon.gateway.internal.common.CarbonCallback;
 import org.wso2.carbon.gateway.internal.common.CarbonMessage;
 import org.wso2.carbon.gateway.internal.common.CarbonMessageProcessor;
+import org.wso2.carbon.gateway.internal.common.Pipe;
 import org.wso2.carbon.gateway.internal.common.TransportSender;
 import org.wso2.carbon.gateway.internal.transport.common.Constants;
+import org.wso2.carbon.gateway.internal.transport.common.HTTPContentChunk;
+import org.wso2.carbon.gateway.internal.transport.common.PipeImpl;
+import org.wso2.carbon.gateway.internal.util.uri.URITemplate;
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
 
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
@@ -47,10 +60,10 @@ public class CamelMediationEngine implements CarbonMessageProcessor {
     }
 
     /**
-     * Client messages will receive here
+     * Client messages will receive here.
      *
-     * @param cMsg            carbon message implementation
-     * @param requestCallback callback object to notify response is ready
+     * @param cMsg            carbon message implementation.
+     * @param requestCallback callback object to notify response is ready.
      */
     public boolean receive(CarbonMessage cMsg, CarbonCallback requestCallback) {
         //start mediation
@@ -58,7 +71,11 @@ public class CamelMediationEngine implements CarbonMessageProcessor {
             log.debug("Channel: {} received body: {}");
         }
         Map<String, Object> transportHeaders = (Map<String, Object>) cMsg.getProperty(Constants.TRANSPORT_HEADERS);
-        CamelMediationConsumer consumer = decideConsumer(cMsg.getURI());
+
+
+        CamelMediationConsumer consumer = decideConsumer(cMsg.getURI(),
+                                                         cMsg.getProperty("HTTP_METHOD").toString(),
+                                                         transportHeaders);
         if (consumer != null) {
             final Exchange exchange = consumer.getEndpoint().createExchange(transportHeaders, cMsg);
             exchange.setPattern(ExchangePattern.InOut);
@@ -69,6 +86,8 @@ public class CamelMediationEngine implements CarbonMessageProcessor {
                 log.error("Unit of Work creation failed");
             }
             processAsynchronously(exchange, consumer, requestCallback);
+        } else {
+            log.error("Message consumer not found.");
         }
         return true;
     }
@@ -81,23 +100,35 @@ public class CamelMediationEngine implements CarbonMessageProcessor {
                                        final CarbonCallback requestCallback) {
 
         consumer.getAsyncProcessor().process(exchange, done -> {
-            //CarbonMessage mediatedResponse = exchange.getOut().getBody(CarbonMessage.class);
-            //Map<String, Object> mediatedHeaders = exchange.getOut().getHeaders();
-            //mediatedResponse.setProperty(Constants.TRANSPORT_HEADERS, mediatedHeaders);
-            CarbonMessage mediatedResponse = null;
-            Object outMesgBody = exchange.getOut().getBody();
-            if (outMesgBody instanceof CarbonMessage) {
-                mediatedResponse = (CarbonMessage) exchange.getOut().getBody();
-            } else if (outMesgBody instanceof String) {
-                mediatedResponse = new CarbonMessage(Constants.PROTOCOL_NAME);
-                mediatedResponse.setSimplePayload((String) outMesgBody);
-                //mediatedResponse.setContentStream(outMessage);
+
+            CarbonMessage mediatedResponse = exchange.getOut().getBody(CarbonMessage.class);
+
+            if (mediatedResponse != null && !exchange.getIn().getMessageId().equals(exchange.getOut().getMessageId())) {
+                Map<String, Object> mediatedHeaders = exchange.getOut().getHeaders();
+                mediatedResponse.setProperty(Constants.TRANSPORT_HEADERS, mediatedHeaders);
             } else {
                 mediatedResponse = new CarbonMessage(Constants.PROTOCOL_NAME);
-                mediatedResponse.setSimplePayload("Error occurred");
+                Exception failedCause = exchange.getException();
+                String cause = failedCause.getMessage();
+                ByteBuf bbuf = Unpooled.copiedBuffer(cause, StandardCharsets.UTF_8);
+                DefaultLastHttpContent lastHttpContent = new DefaultLastHttpContent(bbuf);
+                HTTPContentChunk contentChunk = new HTTPContentChunk(lastHttpContent);
+                Pipe pipe = new PipeImpl(bbuf.readableBytes());
+                pipe.addContentChunk(contentChunk);
+                mediatedResponse.setPipe(pipe);
+
+                mediatedResponse.setDirection(CarbonMessage.RESPONSE);
+
+                Map<String, Object> transportHeaders = new HashMap<>();
+                transportHeaders.put(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.KEEP_ALIVE);
+                transportHeaders.put(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+                transportHeaders.put(HttpHeaders.Names.CONTENT_TYPE, "text/xml");
+                transportHeaders.put(HttpHeaders.Names.CONTENT_LENGTH, bbuf.readableBytes());
+                mediatedResponse.setProperty(Constants.TRANSPORT_HEADERS, transportHeaders);
+
+                mediatedResponse.setProperty(Constants.HTTP_STATUS_CODE, 500);
             }
-            Map<String, Object> mediatedHeaders = exchange.getOut().getHeaders();
-            mediatedResponse.setProperty(Constants.TRANSPORT_HEADERS, mediatedHeaders);
+
             try {
                 requestCallback.done(mediatedResponse);
             } finally {
@@ -106,20 +137,46 @@ public class CamelMediationEngine implements CarbonMessageProcessor {
         });
     }
 
-    private CamelMediationConsumer decideConsumer(String uri) {
+    private CamelMediationConsumer decideConsumer(String uri, String httpMethod,
+                                                  Map<String, Object> transportHeaders) {
 
-        if (consumers.size() == 1) {
-            String key = consumers.keySet().iterator().next();
-            if (uri.contains(key)) {
-                return consumers.get(key);
+        for (String consumerKey : consumers.keySet()) {
+            if (!consumerKey.contains("?httpMethodRestrict=")) {
+                if (uri.contains(consumerKey)) {
+                    return consumers.get(consumerKey);
+                }
             }
         }
-        for (String key : consumers.keySet()) {
-            if (key.contains(uri)) {
-                return consumers.get(key);
+
+        /*Processing requests to REST interfaces */
+        for (String consumerKey : consumers.keySet()) {
+            if (consumerKey.contains("?httpMethodRestrict=")) {
+                Map<String, String> variables = new HashMap<String, String>();
+                URITemplate uriTemplate = null;
+                try {
+                    String[] urlTokens = consumerKey.split(":\\d\\d\\d\\d");
+                    if (urlTokens.length > 0) {
+                        String consumerContextPath = urlTokens[1];
+                        String decodeConsumerURI = URLDecoder.decode(consumerContextPath, "UTF-8");
+                        uriTemplate = new URITemplate(decodeConsumerURI);
+                        boolean isMatch = uriTemplate.matches(uri + "?httpMethodRestrict=" + httpMethod, variables);
+                        if (variables.size() != 0) {
+                            for (Map.Entry<String, String> entry : variables.entrySet()) {
+                                transportHeaders.put(entry.getKey(), entry.getValue());
+                            }
+                        }
+                        if (isMatch) {
+                            return consumers.get(consumerKey);
+                        }
+                    }
+                } catch (URITemplateException e) {
+                    log.error("URI Template " + consumerKey + " is invalid. " + e);
+                } catch (UnsupportedEncodingException e) {
+                    log.error("URI Template " + consumerKey + " encoding error. " + e);
+                }
             }
         }
-        log.warn("No route found for the message URI : " + uri);
+
         return null;
     }
 
@@ -130,4 +187,5 @@ public class CamelMediationEngine implements CarbonMessageProcessor {
     public void removeConsumer(String endpointKey) {
         consumers.remove(endpointKey);
     }
+
 }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationProducer.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationProducer.java
index 1c52ed6..56364e3 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationProducer.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CamelMediationProducer.java
@@ -26,7 +26,6 @@ import org.apache.camel.util.ObjectHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.wso2.carbon.gateway.internal.common.CarbonCallback;
-import org.wso2.carbon.gateway.internal.common.CarbonException;
 import org.wso2.carbon.gateway.internal.common.CarbonMessage;
 import org.wso2.carbon.gateway.internal.transport.common.Constants;
 
@@ -54,7 +53,7 @@ public class CamelMediationProducer extends DefaultAsyncProducer {
         try {
             URL url = new URL(ObjectHelper.after(getEndpoint().getEndpointKey(), "://"));
             host = url.getHost();
-            port = url.getPort();
+            port = (url.getPort() == -1) ? 80 : url.getPort();
             uri = url.getPath();
             carbonCamelMessageUtil = endpoint.getCarbonCamelMessageUtil();
         } catch (MalformedURLException e) {
@@ -63,23 +62,23 @@ public class CamelMediationProducer extends DefaultAsyncProducer {
     }
 
     /**
-     * send request to backend. when response in received callback done method will be invoked
+     * send request to backend. when response in received callback done method will be invoked.
      *
-     * @param exchange camel message exchange
-     * @param callback when the response is received from backend callback done method will be invoked
+     * @param exchange camel message exchange.
+     * @param callback when the response is received from backend callback done method will be invoked.
      */
     public boolean process(Exchange exchange, AsyncCallback callback) {
         //change the header parameters according to the routed endpoint url
-        boolean syncNeeded = true;
         carbonCamelMessageUtil.setCarbonHeadersToBackendRequest(exchange, host, port, uri);
+        //This parameter is used to decide whether we need to continue processing in case of a failure (FO endpoint)
+        boolean syncNeeded = true;
         try {
             syncNeeded = engine.getSender().send(exchange.getIn().getBody(CarbonMessage.class),
-                    new NettyHttpBackEndCallback(exchange, callback));
-        } catch (CarbonException ex) {
-            exchange.setException(ex);
+                                                 new NettyHttpBackEndCallback(exchange, callback));
+        } catch (Exception exp) {
+            //Set the exception to the exchange such that camel can decide on failover
+            exchange.setException(exp);
         }
-        //engine.getSender()
-        //.send(exchange.getIn().getBody(CarbonMessage.class), new NettyHttpBackEndCallback(exchange, callback));
         return syncNeeded;
     }
 
@@ -98,9 +97,9 @@ public class CamelMediationProducer extends DefaultAsyncProducer {
         }
 
         /**
-         * Invoked when the backend response arrived
+         * Invoked when the backend response arrived.
          *
-         * @param responseCmsg response carbon message
+         * @param responseCmsg response carbon message.
          */
         @Override
         public void done(CarbonMessage responseCmsg) {
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CarbonCamelMessageUtil.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CarbonCamelMessageUtil.java
index 827f2eb..91ea1c5 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CarbonCamelMessageUtil.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CarbonCamelMessageUtil.java
@@ -39,11 +39,11 @@ public class CarbonCamelMessageUtil {
     private static Logger log = LoggerFactory.getLogger(CarbonCamelMessageUtil.class);
 
     /**
-     * Get carbon headers from client request and set in the camel exchange in message
+     * Get carbon headers from client request and set in the camel exchange in message.
      *
      * @param exchange         camel exchange
      * @param transportHeaders http headers
-     * @param request          http request carbon message
+     * @param request          http request carbon message.
      */
     public void setCamelHeadersToClientRequest(Exchange exchange, Map<String, Object> transportHeaders,
                                                CarbonMessage request) {
@@ -110,8 +110,8 @@ public class CarbonCamelMessageUtil {
             Map.Entry pair = (Map.Entry) it.next();
 
             if (!Constants.HTTP_CONTENT_TYPE.equals(pair.getKey()) &&
-                    !Constants.HTTP_SOAP_ACTION.equals(pair.getKey()) &&
-                    !Constants.HTTP_CONTENT_ENCODING.equals(pair.getKey())) {
+                !Constants.HTTP_SOAP_ACTION.equals(pair.getKey()) &&
+                !Constants.HTTP_CONTENT_ENCODING.equals(pair.getKey())) {
                 headers.put((String) pair.getKey(), pair.getValue());
             }
             it.remove();
@@ -121,7 +121,7 @@ public class CarbonCamelMessageUtil {
     }
 
     /**
-     * Get camel headers from mediated request and set in carbon message
+     * Get camel headers from mediated request and set in carbon message.
      *
      * @param exchange camel exchange
      * @param host     endpoint host address
@@ -130,8 +130,7 @@ public class CarbonCamelMessageUtil {
      */
     public void setCarbonHeadersToBackendRequest(Exchange exchange, String host, int port, String uri) {
 
-        CarbonMessage request = (CarbonMessage) exchange.getIn().getBody(CarbonMessage.class);
-        //CarbonMessage request = ((CamelHttp4Message) exchange.getIn()).getCarbonMessage();
+        CarbonMessage request = (CarbonMessage) exchange.getIn().getBody();
         Map<String, Object> headers = exchange.getIn().getHeaders();
 
         if (request != null) {
@@ -173,7 +172,7 @@ public class CarbonCamelMessageUtil {
     }
 
     /**
-     * Get carbon headers from backend response and set in camel exchange out message
+     * Get carbon headers from backend response and set in camel exchange out message.
      *
      * @param exchange         camel exchange
      * @param transportHeaders backend response http headers
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CarbonMessageTypeConverter.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CarbonMessageTypeConverter.java
deleted file mode 100644
index 01312b2..0000000
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/mediation/camel/CarbonMessageTypeConverter.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and limitations under the License.
- */
-
-package org.wso2.carbon.gateway.internal.mediation.camel;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufInputStream;
-import io.netty.buffer.Unpooled;
-
-import org.apache.camel.Exchange;
-import org.apache.camel.converter.jaxp.XmlConverter;
-import org.apache.camel.support.TypeConverterSupport;
-import org.apache.log4j.Logger;
-import org.wso2.carbon.gateway.internal.common.CarbonMessage;
-import org.wso2.carbon.gateway.internal.common.ContentChunk;
-import org.wso2.carbon.gateway.internal.common.Pipe;
-import org.wso2.carbon.gateway.internal.transport.common.HTTPContentChunk;
-import org.xml.sax.SAXException;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import javax.xml.parsers.ParserConfigurationException;
-
-
-
-
-/**
- * A type converter which is used to convert to and from array types
- * particularly for derived types of array component types and dealing with
- * primitive array types.
- */
-
-public class CarbonMessageTypeConverter extends TypeConverterSupport {
-    //public final class CarbonMessageTypeConverter {
-    private static final Logger log = Logger.getLogger(CarbonMessageTypeConverter.class);
-
-    @SuppressWarnings("unchecked")
-
-    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
-        if (value instanceof CarbonMessage) {
-            List<ByteBuf> listOfContentBuffers = new ArrayList<ByteBuf>();
-            Pipe pipe = ((CarbonMessage) value).getPipe();
-            ByteBufInputStream byteBufInputStream = null;
-            BlockingQueue<ContentChunk> clonedContent = pipe.getClonedContentQueue();
-            while (true) {
-                HTTPContentChunk httpContentChunk = null;
-                try {
-                    if (clonedContent.isEmpty()) {
-                        break;
-                    } else {
-                        httpContentChunk = (HTTPContentChunk) clonedContent.take();
-                        listOfContentBuffers.add(httpContentChunk.getHttpContent().duplicate().content());
-                    }
-                } catch (InterruptedException e) {
-                    log.error("Error occurred during conversion from CarbonMessage", e);
-                }
-
-            }
-            ByteBuf compositeBuffer
-                    = Unpooled.wrappedBuffer(listOfContentBuffers.toArray(new ByteBuf[listOfContentBuffers.size()]));
-            byteBufInputStream = new ByteBufInputStream(compositeBuffer);
-            XmlConverter xmlConverter = new XmlConverter();
-            try {
-                return (T) xmlConverter.toDOMDocument(byteBufInputStream, exchange);
-            } catch (IOException e) {
-                log.error("IO Error occurred during conversion to XML", e);
-            } catch (SAXException e) {
-                log.error("SAX Parser Error occurred during conversion to XML", e);
-            } catch (ParserConfigurationException e) {
-                log.error("Parser Configuration Error occurred during conversion to XML", e);
-            }
-            //return (T)byteBufInputStream;
-        }
-        return null;
-    }
-
-}
-
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/PipeImpl.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/PipeImpl.java
index 47d4372..adb6d9e 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/PipeImpl.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/PipeImpl.java
@@ -33,12 +33,9 @@ public class PipeImpl implements Pipe {
 
     private BlockingQueue<ContentChunk> contentQueue;
 
-    private BlockingQueue<ContentChunk> clonedContentQueue;
-
 
     public PipeImpl(int blockingQueueSize) {
         this.contentQueue = new LinkedBlockingQueue<>(blockingQueueSize);
-        this.clonedContentQueue = new LinkedBlockingQueue<>(blockingQueueSize);
     }
 
 
@@ -55,20 +52,5 @@ public class PipeImpl implements Pipe {
         contentQueue.add(contentChunk);
     }
 
-    @Override
-    public BlockingQueue<ContentChunk> getClonedContentQueue() {
-        if (!this.contentQueue.isEmpty()) {
-            if (!clonedContentQueue.isEmpty()) {
-                clonedContentQueue.clear();
-            }
-            this.clonedContentQueue.addAll(this.contentQueue);
-        }
-        return this.clonedContentQueue;
-    }
 
-
-    public void clearContent() {
-        this.contentQueue.clear();
-        this.clonedContentQueue.clear();
-    }
 }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/Util.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/Util.java
index b456d2b..6a5a33f 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/Util.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/Util.java
@@ -24,8 +24,6 @@ import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
-
-
 import org.wso2.carbon.gateway.internal.common.CarbonMessage;
 
 import java.util.HashMap;
@@ -34,7 +32,7 @@ import java.util.Map;
 import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
 
 /**
- * Includes utility methods for creating http requests and responses and their related properties
+ * Includes utility methods for creating http requests and responses and their related properties.
  */
 public class Util {
 
@@ -97,27 +95,6 @@ public class Util {
         return outgoingResponse;
     }
 
-
-    @SuppressWarnings("unchecked")
-    public static HttpResponse createHttp202Response() {
-        HttpVersion httpVersion = new HttpVersion(HTTP_1_1.text(), true);
-
-        int statusCode = 202;
-
-        HttpResponseStatus httpResponseStatus = new HttpResponseStatus(statusCode,
-                HttpResponseStatus.valueOf(statusCode).reasonPhrase());
-
-        DefaultHttpResponse outgoingResponse = new DefaultHttpResponse(httpVersion,
-                httpResponseStatus, false);
-
-
-        //Map<String, String> headerMap = (Map) msg.getProperty(Constants.TRANSPORT_HEADERS);
-
-        //Util.setHeaders(outgoingResponse, headerMap);
-
-        return outgoingResponse;
-    }
-
     @SuppressWarnings("unchecked")
     public static HttpRequest createHttpRequest(CarbonMessage msg) {
         HttpMethod httpMethod;
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/config/DisruptorConfig.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/config/DisruptorConfig.java
index eb1696f..c4502cd 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/config/DisruptorConfig.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/config/DisruptorConfig.java
@@ -78,7 +78,7 @@ public class DisruptorConfig {
 
     public RingBuffer getDisruptor() {
         int ind = index.getAndIncrement() % noDisruptors;
-        return disruptorMap.get(ind);
+            return disruptorMap.get(ind);
     }
 
     public void addDisruptor(RingBuffer ringBuffer) {
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/config/DisruptorFactory.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/config/DisruptorFactory.java
index 1664fb9..d063f84 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/config/DisruptorFactory.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/config/DisruptorFactory.java
@@ -26,7 +26,6 @@ import com.lmax.disruptor.TimeoutBlockingWaitStrategy;
 import com.lmax.disruptor.WaitStrategy;
 import com.lmax.disruptor.dsl.Disruptor;
 import com.lmax.disruptor.dsl.ProducerType;
-
 import org.wso2.carbon.gateway.internal.common.CarbonMessageProcessor;
 import org.wso2.carbon.gateway.internal.transport.common.Constants;
 import org.wso2.carbon.gateway.internal.transport.common.disruptor.event.CarbonDisruptorEvent;
@@ -39,7 +38,7 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
 /**
- * Util Class creates Disruptors for Inbound and Outbound Transports
+ * Util Class creates Disruptors for Inbound and Outbound Transports.
  */
 public class DisruptorFactory {
 
@@ -51,13 +50,13 @@ public class DisruptorFactory {
         WaitStrategy inbounsWaitStrategy = getWaitStrategy(disruptorConfig.getDisruptorWaitStrategy());
         for (int i = 0; i < disruptorConfig.getNoDisruptors(); i++) {
             ExecutorService executorService =
-                    Executors.newFixedThreadPool(disruptorConfig.getNoOfEventHandlersPerDisruptor());
+                       Executors.newFixedThreadPool(disruptorConfig.getNoOfEventHandlersPerDisruptor());
             Disruptor disruptor =
-                    new Disruptor<>(CarbonDisruptorEvent.EVENT_FACTORY,
-                            disruptorConfig.getBufferSize(),
-                            executorService,
-                            ProducerType.MULTI,
-                            inbounsWaitStrategy);
+                       new Disruptor<>(CarbonDisruptorEvent.EVENT_FACTORY,
+                                       disruptorConfig.getBufferSize(),
+                                       executorService,
+                                       ProducerType.MULTI,
+                                       inbounsWaitStrategy);
             ExceptionHandler exh = new GenericExceptionHandler();
             EventHandler[] eventHandlers = new EventHandler[disruptorConfig.getNoOfEventHandlersPerDisruptor()];
             for (int j = 0; j < disruptorConfig.getNoOfEventHandlersPerDisruptor(); j++) {
@@ -105,7 +104,7 @@ public class DisruptorFactory {
     }
 
     /**
-     * Describe types of disruptors
+     * Describe types of disruptors.
      */
     public enum DisruptorType {
         INBOUND, OUTBOUND
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/handler/CarbonDisruptorEventHandler.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/handler/CarbonDisruptorEventHandler.java
index 4cc3bbf..d5f848b 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/handler/CarbonDisruptorEventHandler.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/common/disruptor/handler/CarbonDisruptorEventHandler.java
@@ -29,7 +29,7 @@ public class CarbonDisruptorEventHandler extends DisruptorEventHandler {
 
     private CarbonMessageProcessor carbonMessageProcessor;
 
-    public CarbonDisruptorEventHandler(CarbonMessageProcessor engine) {
+    public CarbonDisruptorEventHandler(CarbonMessageProcessor  engine) {
         carbonMessageProcessor = engine;
     }
 
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/GatewayNettyInitializer.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/GatewayNettyInitializer.java
index eae1165..4542059 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/GatewayNettyInitializer.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/GatewayNettyInitializer.java
@@ -23,10 +23,8 @@ import org.apache.camel.spring.SpringCamelContext;
 import org.apache.log4j.Logger;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.support.ClassPathXmlApplicationContext;
-import org.wso2.carbon.gateway.internal.common.CarbonMessage;
 import org.wso2.carbon.gateway.internal.mediation.camel.CamelMediationComponent;
 import org.wso2.carbon.gateway.internal.mediation.camel.CamelMediationEngine;
-import org.wso2.carbon.gateway.internal.mediation.camel.CarbonMessageTypeConverter;
 import org.wso2.carbon.gateway.internal.transport.common.Constants;
 import org.wso2.carbon.gateway.internal.transport.common.disruptor.config.DisruptorConfig;
 import org.wso2.carbon.gateway.internal.transport.common.disruptor.config.DisruptorFactory;
@@ -48,9 +46,9 @@ public class GatewayNettyInitializer implements CarbonNettyServerInitializer {
     private ConnectionManager connectionManager;
 
     public static final String CAMEL_CONTEXT_CONFIG_FILE = "repository" + File.separator + "conf" +
-            File.separator +
-            "camel" + File.separator
-            + "camel-context.xml";
+                                                           File.separator +
+                                                           "camel" + File.separator
+                                                           + "camel-context.xml";
 
     public GatewayNettyInitializer() {
 
@@ -70,8 +68,6 @@ public class GatewayNettyInitializer implements CarbonNettyServerInitializer {
             SpringCamelContext camelContext = (SpringCamelContext) applicationContext.getBean("wso2-cc");
             camelContext.start();
             CamelMediationComponent component = (CamelMediationComponent) camelContext.getComponent("wso2-gw");
-            camelContext.getTypeConverterRegistry().addTypeConverter(org.w3c.dom.Document.class, CarbonMessage.class,
-                    new CarbonMessageTypeConverter());
             CamelMediationEngine engine = component.getEngine();
             connectionManager = component.getConnectionManager();
 
@@ -85,20 +81,21 @@ public class GatewayNettyInitializer implements CarbonNettyServerInitializer {
                                 parameters.get(Constants.WAIT_STRATEGY),
                                 Boolean.parseBoolean(Constants.SHARE_DISRUPTOR_WITH_OUTBOUND));
                 DisruptorFactory.createDisruptors(DisruptorFactory.DisruptorType.INBOUND,
-                        disruptorConfig, engine);
+                                                  disruptorConfig, engine);
                 String queueSize = parameters.get(Constants.CONTENT_QUEUE_SIZE);
                 if (queueSize != null) {
                     this.queueSize = Integer.parseInt(queueSize);
                 }
             } else {
                 log.warn("Disruptor specific parameters are not specified in " +
-                        "configuration hence using default configs");
+                         "configuration hence using default configs");
                 DisruptorConfig disruptorConfig = new DisruptorConfig();
                 DisruptorFactory.createDisruptors(DisruptorFactory.DisruptorType.INBOUND,
-                        disruptorConfig, engine);
+                                                  disruptorConfig, engine);
             }
         } catch (Exception e) {
             String msg = "Error while loading " + CAMEL_CONTEXT_CONFIG_FILE + " configuration file";
+            log.error(msg + e);
             throw new RuntimeException(msg, e);
         }
     }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/ResponseCallback.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/ResponseCallback.java
index 14b79b9..15b6d5e 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/ResponseCallback.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/ResponseCallback.java
@@ -15,11 +15,7 @@
 
 package org.wso2.carbon.gateway.internal.transport.listener;
 
-import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
@@ -29,9 +25,6 @@ import org.wso2.carbon.gateway.internal.common.Pipe;
 import org.wso2.carbon.gateway.internal.transport.common.HTTPContentChunk;
 import org.wso2.carbon.gateway.internal.transport.common.Util;
 
-import java.nio.ByteBuffer;
-import java.nio.charset.StandardCharsets;
-
 /**
  * A Class responsible for handling the response.
  */
@@ -45,28 +38,6 @@ public class ResponseCallback implements CarbonCallback {
 
     public void done(CarbonMessage cMsg) {
         final Pipe pipe = cMsg.getPipe();
-        if (pipe == null) {
-            //final HttpResponse response = Util.createHttp202Response();
-
-            HttpResponse response = Util.createHttp202Response();
-            DefaultHttpContent responseBody = new DefaultHttpContent(Unpooled.wrappedBuffer(ByteBuffer.wrap
-                    (((String) cMsg.getSimplePayload()).getBytes(StandardCharsets.UTF_8))));
-            //ByteBufInputStream msgContent = cMsg.getContentStream();
-
-            //response.setContent(ChannelBuffers.copiedBuffer("pong", CharsetUtil.UTF_8));
-            //response.setHeader(CONTENT_TYPE, "text/plain; charset=UTF-8");
-            // ctx.write(response).addListener(ChannelFutureListener.CLOSE);
-            ctx.write(response);
-            final ChannelFuture f = ctx.writeAndFlush(responseBody); // (3)
-            f.addListener(new ChannelFutureListener() {
-                @Override
-                public void operationComplete(ChannelFuture future) {
-                    assert f == future;
-                    ctx.close();
-                }
-            });
-            return;
-        }
         final HttpResponse response = Util.createHttpResponse(cMsg);
         ctx.write(response);
         while (true) {
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/SourceHandler.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/SourceHandler.java
index b65d392..dd539b7 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/SourceHandler.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/listener/SourceHandler.java
@@ -56,7 +56,7 @@ public class SourceHandler extends ChannelInboundHandlerAdapter {
     private DisruptorConfig disruptorConfig;
     private Map<String, GenericObjectPool> targetChannelPool;
 
-    public SourceHandler(int queueSize, ConnectionManager connectionManager) throws Exception {
+    public SourceHandler(int queueSize , ConnectionManager connectionManager) throws Exception {
         this.queueSize = queueSize;
         this.connectionManager = connectionManager;
     }
@@ -126,6 +126,7 @@ public class SourceHandler extends ChannelInboundHandlerAdapter {
     }
 
 
+
     public Map<String, GenericObjectPool> getTargetChannelPool() {
         return targetChannelPool;
     }
@@ -137,7 +138,7 @@ public class SourceHandler extends ChannelInboundHandlerAdapter {
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         super.exceptionCaught(ctx, cause);
-        log.error("Exception caught in Netty Source handler", cause);
+        log.error("Exception caught in Netty Source handler" , cause);
     }
 }
 
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/NettySender.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/NettySender.java
index b9bcb3c..845cb72 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/NettySender.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/NettySender.java
@@ -23,8 +23,8 @@ import io.netty.handler.codec.http.LastHttpContent;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.wso2.carbon.gateway.internal.common.CarbonCallback;
-import org.wso2.carbon.gateway.internal.common.CarbonException;
 import org.wso2.carbon.gateway.internal.common.CarbonMessage;
+import org.wso2.carbon.gateway.internal.common.GWException;
 import org.wso2.carbon.gateway.internal.common.TransportSender;
 import org.wso2.carbon.gateway.internal.transport.common.Constants;
 import org.wso2.carbon.gateway.internal.transport.common.HTTPContentChunk;
@@ -47,15 +47,13 @@ public class NettySender implements TransportSender {
 
     private ConnectionManager connectionManager;
 
-
     public NettySender(Config conf, ConnectionManager connectionManager) {
         this.config = conf;
         this.connectionManager = connectionManager;
     }
 
-
     @Override
-    public boolean send(CarbonMessage msg, CarbonCallback callback) throws CarbonException {
+    public boolean send(CarbonMessage msg, CarbonCallback callback) throws GWException {
 
         final HttpRequest httpRequest = Util.createHttpRequest(msg);
 
@@ -81,20 +79,14 @@ public class NettySender implements TransportSender {
             targetChannel.getTargetHandler().setTargetChannel(targetChannel);
             targetChannel.getTargetHandler().setConnectionManager(connectionManager);
 
-
             writeContent(outboundChannel, httpRequest, msg);
-
-
-        } catch (Exception e) {
-            log.error("Cannot processed Request to host " + route.toString(), e);
-            throw new CarbonException("Endpoint failed", e);
-            //return false;
+        } catch (Exception failedCause) {
+            throw new GWException(failedCause.getMessage(), failedCause);
         }
 
         return false;
     }
 
-
     private boolean writeContent(Channel channel, HttpRequest httpRequest, CarbonMessage carbonMessage) {
         channel.write(httpRequest);
         while (true) {
@@ -111,7 +103,6 @@ public class NettySender implements TransportSender {
         return true;
     }
 
-
     /**
      * Class representing configs related to Transport Sender.
      */
@@ -123,7 +114,6 @@ public class NettySender implements TransportSender {
 
         private int queueSize;
 
-
         public Config(String id) {
             if (id == null) {
                 throw new IllegalArgumentException("Netty transport ID is null");
@@ -135,7 +125,6 @@ public class NettySender implements TransportSender {
             return id;
         }
 
-
         public Config enableSsl(SSLConfig sslConfig) {
             this.sslConfig = sslConfig;
             return this;
@@ -145,7 +134,6 @@ public class NettySender implements TransportSender {
             return sslConfig;
         }
 
-
         public int getQueueSize() {
             return queueSize;
         }
@@ -155,7 +143,6 @@ public class NettySender implements TransportSender {
             return this;
         }
 
-
     }
 
 }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/BootstrapConfiguration.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/BootstrapConfiguration.java
index 4cd234b..21e11b8 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/BootstrapConfiguration.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/BootstrapConfiguration.java
@@ -22,7 +22,7 @@ import java.util.Map;
 
 
 /**
- * A class represents client bootstrap configurations
+ * A class represents client bootstrap configurations.
  */
 public class BootstrapConfiguration {
 
@@ -45,16 +45,16 @@ public class BootstrapConfiguration {
 
         if (parameters != null) {
             tcpNoDelay = parameters.get(Constants.CLINET_BOOTSTRAP_TCP_NO_DELY) == null ||
-                    Boolean.parseBoolean(parameters.get(Constants.CLINET_BOOTSTRAP_TCP_NO_DELY));
+                         Boolean.parseBoolean(parameters.get(Constants.CLINET_BOOTSTRAP_TCP_NO_DELY));
             connectTimeOut = parameters.get(Constants.CLINET_BOOTSTRAP_CONNECT_TIME_OUT) != null ?
-                    Integer.parseInt(parameters.get(Constants.CLINET_BOOTSTRAP_CONNECT_TIME_OUT)) : 15000;
+                             Integer.parseInt(parameters.get(Constants.CLINET_BOOTSTRAP_CONNECT_TIME_OUT)) : 15000;
             reciveBufferSize = parameters.get(Constants.CLINET_BOOTSTRAP_RECEIVE_BUFFER_SIZE) != null ?
-                    Integer.parseInt
-                            (parameters.get(Constants.CLINET_BOOTSTRAP_RECEIVE_BUFFER_SIZE)) : 1048576;
+                               Integer.parseInt
+                                          (parameters.get(Constants.CLINET_BOOTSTRAP_RECEIVE_BUFFER_SIZE)) : 1048576;
             sendBufferSize = parameters.get(Constants.CLINET_BOOTSTRAP_SEND_BUFFER_SIZE) != null ?
-                    Integer.parseInt(parameters.get(Constants.CLINET_BOOTSTRAP_SEND_BUFFER_SIZE)) : 1048576;
+                             Integer.parseInt(parameters.get(Constants.CLINET_BOOTSTRAP_SEND_BUFFER_SIZE)) : 1048576;
             keepAlive = parameters.get(Constants.CLINET_BOOTSTRAP_KEEPALIVE) == null ||
-                    Boolean.parseBoolean(parameters.get(Constants.CLINET_BOOTSTRAP_KEEPALIVE));
+                        Boolean.parseBoolean(parameters.get(Constants.CLINET_BOOTSTRAP_KEEPALIVE));
             socketReuse = Boolean.parseBoolean(parameters.get(Constants.CLINET_BOOTSTRAP_SO_REUSE));
 
         }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/ChannelUtils.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/ChannelUtils.java
index 3228af1..20765b2 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/ChannelUtils.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/ChannelUtils.java
@@ -31,15 +31,14 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 /**
- * Utility class for Channel handling
+ * Utility class for Channel handling.
  */
 public class ChannelUtils {
 
     private static final Logger log = LoggerFactory.getLogger(ChannelUtils.class);
 
-
     /**
-     * Provides incomplete Netty channel future
+     * Provides incomplete Netty channel future.
      *
      * @param targetChannel  Target channel which has channel specific parameters such as handler
      * @param eventLoopGroup Event loop group of inbound IO workers
@@ -59,27 +58,25 @@ public class ChannelUtils {
         clientBootstrap.option(ChannelOption.SO_REUSEADDR, bootstrapConfiguration.isSocketReuse());
         clientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, bootstrapConfiguration.getConnectTimeOut());
 
-
         // set the pipeline factory, which creates the pipeline for each newly created channels
         TargetInitializer targetInitializer = new TargetInitializer();
         targetChannel.setTargetInitializer(targetInitializer);
         clientBootstrap.handler(targetInitializer);
         if (log.isDebugEnabled()) {
             log.debug("Created new TCP client bootstrap connecting to {}:{} with options: {}",
-                    httpRoute.getHost(), httpRoute.getPort(), clientBootstrap);
+                      httpRoute.getHost(), httpRoute.getPort(), clientBootstrap);
         }
 
         return clientBootstrap.connect(new InetSocketAddress(httpRoute.getHost(), httpRoute.getPort()));
     }
 
-
     /**
-     * Open Channel for BE
+     * Open Channel for BE.
      *
      * @param channelFuture ChannelFuture Object
      * @param httpRoute     HttpRoute represents host and port for BE
      * @return Channel
-     * @throws Exception
+     * @throws Exception Exception to notify any errors occur during opening the channel
      */
     public static Channel openChannel(ChannelFuture channelFuture, HttpRoute httpRoute) throws Exception {
 
@@ -87,7 +84,7 @@ public class ChannelUtils {
         // blocking for channel to be done
         if (log.isTraceEnabled()) {
             log.trace("Waiting for operation to complete {} for {} millis", channelFuture,
-                    bootstrapConfiguration.getConnectTimeOut());
+                      bootstrapConfiguration.getConnectTimeOut());
         }
 
         // here we need to wait it in other thread
@@ -100,21 +97,29 @@ public class ChannelUtils {
             throw new Exception("Interrupted while waiting for " + "connection to " + httpRoute.toString());
         }
 
+        Channel channel = null;
 
-        if (!channelFuture.isDone() || !channelFuture.isSuccess()) {
-            ConnectException cause = new ConnectException("Cannot connect to " + httpRoute.toString());
+        if (channelFuture.isDone() && channelFuture.isSuccess()) {
+            channel = channelFuture.channel();
+            if (log.isDebugEnabled()) {
+                log.debug("Creating connector to address: {}", httpRoute.toString());
+            }
+        } else if (channelFuture.isDone() && channelFuture.isCancelled()) {
+            ConnectException cause = new ConnectException("Request Cancelled, " + httpRoute.toString());
+            if (channelFuture.cause() != null) {
+                cause.initCause(channelFuture.cause());
+            }
+            throw cause;
+        } else if (!channelFuture.isDone() && !channelFuture.isSuccess() &&
+                   !channelFuture.isCancelled() && (channelFuture.cause() == null)) {
+            throw new ConnectException("Connection timeout, " + httpRoute.toString());
+        } else {
+            ConnectException cause = new ConnectException("Connection refused, " + httpRoute.toString());
             if (channelFuture.cause() != null) {
                 cause.initCause(channelFuture.cause());
             }
             throw cause;
-        }
-
-        Channel channel = channelFuture.channel();
-
-        if (log.isDebugEnabled()) {
-            log.debug("Creating connector to address: {}", httpRoute.toString());
         }
         return channel;
     }
-
 }
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/ConnectionManager.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/ConnectionManager.java
index 18bcd0a..c279d6e 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/ConnectionManager.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/ConnectionManager.java
@@ -35,7 +35,7 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- * A class which handles connection pool management
+ * A class which handles connection pool management.
  */
 public class ConnectionManager {
 
@@ -84,7 +84,7 @@ public class ConnectionManager {
         config.minEvictableIdleTimeMillis = poolConfiguration.getMinEvictableIdleTime();
         config.whenExhaustedAction = poolConfiguration.getExhaustedAction();
         return new GenericObjectPool(new PoolableTargetChannelFactory(httpRoute, eventLoopGroup, eventLoopClass),
-                config);
+                                     config);
 
 
     }
@@ -104,15 +104,15 @@ public class ConnectionManager {
     }
 
     /**
-     * Provide target channel for given http route
+     * Provide target channel for given http route.
      *
      * @param httpRoute     BE address
      * @param sourceHandler Incoming channel
-     * @return
-     * @throws Exception
+     * @return TargetChannel
+     * @throws Exception   Exception to notify any errors occur during retrieving the target channel
      */
     public TargetChannel getTargetChannel(HttpRoute httpRoute, SourceHandler sourceHandler)
-            throws Exception {
+               throws Exception {
         Channel channel = null;
         TargetChannel targetChannel = null;
         ChannelHandlerContext ctx = sourceHandler.getInboundChannelContext();
@@ -146,10 +146,8 @@ public class ConnectionManager {
 
                 try {
                     channel = ChannelUtils.openChannel(future, httpRoute);
-                } catch (Exception e) {
-                    log.error("Cannot establish connection with " + httpRoute.toString(), e);
-                    log.info("Reconnecting to " + httpRoute.toString());
-                    channel = ChannelUtils.openChannel(future, httpRoute);
+                } catch (Exception failedCause) {
+                    throw failedCause;
                 } finally {
                     if (channel != null) {
                         targetChannel.setChannel(channel);
@@ -204,14 +202,14 @@ public class ConnectionManager {
 
 
     /**
-     * Provide specific target channel map
+     * Provide specific target channel map.
      *
      * @return Map contains pools for each route
      */
     public Map<String, GenericObjectPool> getTargetChannelPool() {
         if (poolManagementPolicy == PoolManagementPolicy.GLOBAL_ENDPOINT_CONNECTION_CACHING) {
             int ind = index.getAndIncrement() % poolCount;
-            return mapList.get(ind);
+                return mapList.get(ind);
         }
         return null;
     }
@@ -225,7 +223,7 @@ public class ConnectionManager {
 
 
     /**
-     * Connection pool management policies for  target channels
+     * Connection pool management policies for  target channels.
      */
     public enum PoolManagementPolicy {
         PER_SERVER_CHANNEL_ENDPOINT_CONNECTION_CACHING,
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/PoolConfiguration.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/PoolConfiguration.java
index 165bd7e..0d3a7ce 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/PoolConfiguration.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/PoolConfiguration.java
@@ -21,7 +21,7 @@ import org.wso2.carbon.gateway.internal.transport.common.Constants;
 import java.util.Map;
 
 /**
- * A class which represents connection pool specific parameters
+ * A class which represents connection pool specific parameters.
  */
 public class PoolConfiguration {
 
@@ -51,16 +51,16 @@ public class PoolConfiguration {
 
         if (parameters != null) {
             numberOfPools = parameters.get(Constants.NUMBER_OF_POOLS) != null ?
-                    Integer.parseInt(parameters.get(Constants.NUMBER_OF_POOLS)) : 0;
+                            Integer.parseInt(parameters.get(Constants.NUMBER_OF_POOLS)) : 0;
             maxActivePerPool = parameters.get(Constants.MAX_ACTIVE_CONNECTIONS_PER_POOL) != null ?
-                    Integer.parseInt(parameters.get(Constants.MAX_ACTIVE_CONNECTIONS_PER_POOL)) : -1;
+                               Integer.parseInt(parameters.get(Constants.MAX_ACTIVE_CONNECTIONS_PER_POOL)) : -1;
             minIdlePerPool = parameters.get(Constants.MIN_IDLE_CONNECTIONS_PER_POOL) != null ?
-                    Integer.parseInt
-                            (parameters.get(Constants.MIN_IDLE_CONNECTIONS_PER_POOL)) : 0;
+                             Integer.parseInt
+                                        (parameters.get(Constants.MIN_IDLE_CONNECTIONS_PER_POOL)) : 0;
             maxIdlePerPool = parameters.get(Constants.MAX_IDLE_CONNECTIONS_PER_POOL) != null ?
-                    Integer.parseInt(parameters.get(Constants.MAX_IDLE_CONNECTIONS_PER_POOL)) : 100;
+                             Integer.parseInt(parameters.get(Constants.MAX_IDLE_CONNECTIONS_PER_POOL)) : 100;
             minEvictableIdleTime = parameters.get(Constants.MIN_EVICTION_IDLE_TIME) != null ?
-                    Integer.parseInt(parameters.get(Constants.MIN_EVICTION_IDLE_TIME)) : 5 * 60 * 1000L;
+                                   Integer.parseInt(parameters.get(Constants.MIN_EVICTION_IDLE_TIME)) : 5 * 60 * 1000L;
 
         }
 
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/PoolableTargetChannelFactory.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/PoolableTargetChannelFactory.java
index f93caf6..4487a0c 100644
--- a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/PoolableTargetChannelFactory.java
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/transport/sender/channel/pool/PoolableTargetChannelFactory.java
@@ -27,7 +27,7 @@ import org.wso2.carbon.gateway.internal.transport.sender.channel.ChannelUtils;
 import org.wso2.carbon.gateway.internal.transport.sender.channel.TargetChannel;
 
 /**
- * A class which creates a TargetChannel pool for each route
+ * A class which creates a TargetChannel pool for each route.
  */
 public class PoolableTargetChannelFactory implements PoolableObjectFactory {
 
@@ -48,7 +48,7 @@ public class PoolableTargetChannelFactory implements PoolableObjectFactory {
     public Object makeObject() throws Exception {
         TargetChannel targetChannel = new TargetChannel();
         ChannelFuture channelFuture = ChannelUtils.getNewChannelFuture(targetChannel,
-                eventLoopGroup, eventLoopClass, httpRoute);
+                                                                       eventLoopGroup, eventLoopClass, httpRoute);
         Channel channel = ChannelUtils.openChannel(channelFuture, httpRoute);
         log.debug("Created channel: {}", channel);
         targetChannel.setChannel(channel);
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/URITemplate.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/URITemplate.java
new file mode 100644
index 0000000..7243c6b
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/URITemplate.java
@@ -0,0 +1,54 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.parser.Node;
+import org.wso2.carbon.gateway.internal.util.uri.parser.URITemplateParser;
+
+import java.util.Map;
+
+
+/**
+ * URI Template with matching support.
+ */
+
+public class URITemplate {
+
+    private Node syntaxTree;
+
+    public URITemplate(String template) throws URITemplateException {
+        if (!"/".equals(template) && template.endsWith("/")) {
+            template = template.substring(0, template.length() - 1);
+        }
+        URITemplateParser parser = new URITemplateParser();
+        syntaxTree = parser.parse(template);
+    }
+
+    public String expand(Map<String, String> variables) {
+        return null;
+    }
+
+    public boolean matches(String uri, Map<String, String> variables) {
+        /* if (uri.endsWith("/") && uri.length() > 1) {
+            uri = uri.substring(0, uri.length() - 1);
+        } */
+        return syntaxTree.matchAll(uri, variables) == uri.length();
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/URITemplateException.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/URITemplateException.java
new file mode 100644
index 0000000..2c9590a
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/URITemplateException.java
@@ -0,0 +1,35 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri;
+
+
+/**
+ * URITemplateException representation.
+ */
+
+public class URITemplateException extends Exception {
+
+    public URITemplateException(String message) {
+        super(message);
+    }
+
+    public URITemplateException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Expression.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Expression.java
new file mode 100644
index 0000000..dd6d5c2
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Expression.java
@@ -0,0 +1,87 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * URI Template Expression.
+ */
+public abstract class Expression extends Node {
+
+    protected List<Variable> variableList = new ArrayList<Variable>(4);
+
+    public Expression(String token) throws URITemplateException {
+        super(token);
+        int startIndex = 0;
+        for (int i = 0; i < token.length(); i++) {
+            if (token.charAt(i) == ',') {
+                if (startIndex == i) {
+                    throw new URITemplateException("Illegal variable reference with zero length");
+                } else {
+                    variableList.add(new Variable(token.substring(startIndex, i)));
+                    startIndex = i + 1;
+                }
+            } else if (i == token.length() - 1) {
+                if (startIndex < token.length()) {
+                    variableList.add(new Variable(token.substring(startIndex, i + 1)));
+                }
+            }
+        }
+    }
+
+    @Override
+    String getToken() {
+        String str = "{";
+        boolean first = true;
+        for (Variable var : variableList) {
+            if (!first) {
+                str += ",";
+            } else {
+                first = false;
+            }
+            str = str.concat(var.getName());
+        }
+        str += "}";
+        return str;
+    }
+
+    protected String encodeValue(String value) {
+        try {
+            return URLEncoder.encode(value, "UTF-8").replaceAll("\\+", "%20");
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException("Error while encoding value: " + value, e);
+        }
+    }
+
+    protected String decodeValue(String value) {
+        try {
+            return URLDecoder.decode(value.replaceAll("\\+", "%2B"), "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException("Error while encoding value: " + value, e);
+        }
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/FragmentExpression.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/FragmentExpression.java
new file mode 100644
index 0000000..8d0a1db
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/FragmentExpression.java
@@ -0,0 +1,56 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+import java.util.Map;
+
+/**
+ * Expression Fragment impl.
+ */
+public class FragmentExpression extends ReservedStringExpression {
+
+    public FragmentExpression(String token) throws URITemplateException {
+        super(token);
+    }
+
+    @Override
+    String expand(Map<String, String> variables) {
+        String result = super.expand(variables);
+        if (result != null) {
+            return getFirstCharacter() + result;
+        }
+        return result;
+    }
+
+    @Override
+    int match(String uriFragment, Map<String, String> variables) {
+        if (uriFragment.startsWith(String.valueOf(getFirstCharacter()))) {
+            return super.match(uriFragment.substring(1), variables) + 1;
+        }
+        return 0;
+    }
+
+    @Override
+    char getFirstCharacter() {
+        return '#';
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/LabelExpression.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/LabelExpression.java
new file mode 100644
index 0000000..13c93b3
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/LabelExpression.java
@@ -0,0 +1,62 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+import java.util.Map;
+
+/**
+ * LabelExpression impl.
+ */
+
+public class LabelExpression extends SimpleStringExpression {
+
+    public LabelExpression(String token) throws URITemplateException {
+        super(token);
+    }
+
+    @Override
+    String expand(Map<String, String> variables) {
+        String result = super.expand(variables);
+        if (result != null) {
+            return getSeparator() + result;
+        }
+        return result;
+    }
+
+    @Override
+    int match(String uriFragment, Map<String, String> variables) {
+        if (uriFragment.startsWith(String.valueOf(getSeparator()))) {
+            return super.match(uriFragment.substring(1), variables) + 1;
+        }
+        return 0;
+    }
+
+    @Override
+    protected char getSeparator() {
+        return '.';
+    }
+
+    @Override
+    char getFirstCharacter() {
+        return getSeparator();
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Literal.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Literal.java
new file mode 100644
index 0000000..6af05d3
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Literal.java
@@ -0,0 +1,86 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+import java.util.Map;
+
+/**
+ * Literal.
+ */
+public class Literal extends Node {
+
+    private int tokenLength = 0;
+
+    public Literal(String token) throws URITemplateException {
+        super(token);
+        tokenLength = token.length();
+        if (tokenLength == 0) {
+            throw new URITemplateException("Invalid literal token with zero length");
+        }
+    }
+
+    @Override
+    String expand(Map<String, String> variables) {
+        return token;
+    }
+
+    @Override
+    int match(String uriFragment, Map<String, String> variables) {
+        if (!token.endsWith("*")) {
+            if (uriFragment.length() < tokenLength) {
+                return -1;
+            }
+            for (int i = 0; i < tokenLength; i++) {
+                if (token.charAt(i) != uriFragment.charAt(i)) {
+                    if (token.charAt(i) == '*' && i == token.length() - 1) {
+                        return uriFragment.length();
+                    }
+                    return -1;
+                }
+            }
+            return tokenLength;
+        } else {
+            if (uriFragment.length() < tokenLength - 1) {
+                return -1;
+            }
+            for (int i = 0; i < tokenLength - 1; i++) {
+                if (token.charAt(i) != uriFragment.charAt(i)) {
+                    if (i == token.length() - 1) {
+                        return uriFragment.length();
+                    }
+                    return -1;
+                }
+            }
+            return uriFragment.length();
+        }
+    }
+
+    @Override
+    String getToken() {
+        return token;
+    }
+
+    @Override
+    char getFirstCharacter() {
+        return token.charAt(0);
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Node.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Node.java
new file mode 100644
index 0000000..7fc2df2
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Node.java
@@ -0,0 +1,85 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+import java.util.Map;
+
+/**
+ * Node abstraction.
+ */
+public abstract class Node {
+
+    protected String token;
+    protected Node next;
+
+    protected Node(String token) {
+        this.token = token;
+    }
+
+    public void setNext(Node next) {
+        this.next = next;
+    }
+
+    public String expandAll(Map<String, String> variables) {
+        StringBuilder builder = new StringBuilder();
+        Node currentNode = this;
+        while (currentNode != null) {
+            builder.append(currentNode.expand(variables));
+            currentNode = currentNode.next;
+        }
+        return builder.toString();
+    }
+
+    public int matchAll(String uriFragment, Map<String, String> variables) {
+        int matchLength = match(uriFragment, variables);
+        if (matchLength < 0) {
+            return -1;
+        } else if (matchLength < uriFragment.length()) {
+            if (next != null) {
+                uriFragment = uriFragment.substring(matchLength);
+                return matchLength + next.matchAll(uriFragment, variables);
+            } else {
+                // We have more content in the URI to match
+                // But there aren't any nodes left to match against
+                // return -1;
+                if (uriFragment.endsWith("/")) {
+                    matchLength = matchLength + 1;
+                }
+                return matchLength;
+            }
+        } else if (matchLength == uriFragment.length() && next != null) {
+            if (next.getToken().equalsIgnoreCase("*")) {
+                return matchLength;
+            }
+            if (next.getToken().equalsIgnoreCase("/*")) {
+                return matchLength;
+            }
+            // We have matched all the characters in the URI
+            // But there are some nodes left to be matched against
+            return -1;
+        } else {
+            return matchLength;
+        }
+    }
+
+    abstract String expand(Map<String, String> variables);
+    abstract int match(String uriFragment, Map<String, String> variables);
+    abstract String getToken();
+    abstract char getFirstCharacter();
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/PathSegmentExpression.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/PathSegmentExpression.java
new file mode 100644
index 0000000..e3fec99
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/PathSegmentExpression.java
@@ -0,0 +1,37 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+/**
+ * PathSegment Impl.
+ */
+public class PathSegmentExpression extends LabelExpression {
+
+    public PathSegmentExpression(String token) throws URITemplateException {
+        super(token);
+    }
+
+    @Override
+    protected char getSeparator() {
+        return '/';
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/ReservedStringExpression.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/ReservedStringExpression.java
new file mode 100644
index 0000000..3c0c65f
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/ReservedStringExpression.java
@@ -0,0 +1,74 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+import java.util.Map;
+
+/**
+ * ReservedStringExpression Impl.
+ */
+
+public class ReservedStringExpression extends SimpleStringExpression {
+
+    public ReservedStringExpression(String token) throws URITemplateException {
+        super(token);
+    }
+
+    @Override
+    protected boolean isReserved(char ch) {
+        return false;
+    }
+
+    @Override
+    protected String encodeValue(String value) {
+        StringBuilder builder = new StringBuilder();
+        for (int i = 0; i < value.length(); i++) {
+            char ch = value.charAt(i);
+            if (super.isReserved(ch)) {
+                builder.append(ch);
+            } else {
+                builder.append(super.encodeValue(String.valueOf(ch)));
+            }
+        }
+        return builder.toString();
+    }
+
+    @Override
+    protected boolean setVariables(String expressionValue, Map<String, String> variables) {
+        if (variableList.size() == 1) {
+            Variable var = variableList.get(0);
+            String name = var.getName();
+            String finalValue = decodeValue(expressionValue);
+            if (variables.containsKey(name) && !finalValue.equals(variables.get(name))) {
+                return false;
+            }
+
+            if (var.checkModifier(finalValue)) {
+                variables.put(name, finalValue);
+                return true;
+            } else {
+                return false;
+            }
+        }
+        return super.setVariables(expressionValue, variables);
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/SimpleStringExpression.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/SimpleStringExpression.java
new file mode 100644
index 0000000..c48341b
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/SimpleStringExpression.java
@@ -0,0 +1,149 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+import java.util.Map;
+import java.util.regex.Pattern;
+
+
+/**
+ * Simple string expression Impl.
+ */
+
+public class SimpleStringExpression extends Expression {
+
+    private static final char[] reserved = new char[] {
+            ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', '\'', '(', ')', '*', '+', ',', ';', '='
+    };
+
+    public SimpleStringExpression(String token) throws URITemplateException {
+        super(token);
+    }
+
+    @Override
+    String expand(Map<String, String> variables) {
+        boolean emptyString = false;
+        StringBuffer buffer = new StringBuffer();
+        for (Variable var : variableList) {
+            String name = var.getName();
+            if (variables.containsKey(name)) {
+                if (buffer.length() > 0) {
+                    buffer.append(getSeparator());
+                }
+                String value = var.modify(variables.get(name));
+                if ("".equals(value)) {
+                    emptyString = true;
+                }
+                buffer.append(encodeValue(value));
+            }
+        }
+
+        if (buffer.length() == 0 && !emptyString) {
+            return null;
+        }
+        return buffer.toString();
+    }
+
+    protected char getSeparator() {
+        return ',';
+    }
+
+    @Override
+    int match(String uriFragment, Map<String, String> variables) {
+        int length = uriFragment.length();
+        for (int i = 0; i < length; i++) {
+            char ch = uriFragment.charAt(i);
+            if (isReserved(ch) || (next != null && ch == next.getFirstCharacter())) {
+                if (ch == getSeparator() && variableList.size() > 0) {
+                    continue;
+                }
+
+                if (!setVariables(uriFragment.substring(0, i), variables)) {
+                    return -1;
+                }
+                return i;
+            } else if (i == length - 1) {
+                if (!setVariables(uriFragment, variables)) {
+                    return -1;
+                }
+                return length;
+            }
+        }
+        return 0;
+    }
+
+    protected boolean setVariables(String expressionValue, Map<String, String> variables) {
+        String separator = Pattern.quote(String.valueOf(getSeparator()));
+        String[] values = expressionValue.split(separator);
+        int length = values.length;
+        if (length > variableList.size()) {
+            return false;
+        }
+
+        for (int i = 0; i < length; i++) {
+            Variable var = variableList.get(i);
+            String name = var.getName();
+            String finalValue = decodeValue(values[i]);
+            if (variables.containsKey(name) && !finalValue.equals(variables.get(name))) {
+                return false;
+            }
+
+            if (var.checkModifier(finalValue)) {
+                variables.put(name, finalValue);
+            } else {
+                return false;
+            }
+        }
+
+        if (variableList.size() > length) {
+            for (int i = length; i < variableList.size(); i++) {
+                Variable var = variableList.get(i);
+                String name = var.getName();
+                String finalValue = "";
+                if (variables.containsKey(name) && !finalValue.equals(variables.get(name))) {
+                    return false;
+                }
+
+                if (var.checkModifier(finalValue)) {
+                    variables.put(name, finalValue);
+                } else {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    @Override
+    char getFirstCharacter() {
+        return '\u0001';
+    }
+
+    protected boolean isReserved(char ch) {
+        for (char reservedChar : reserved) {
+            if (ch == reservedChar) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/URITemplateParser.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/URITemplateParser.java
new file mode 100644
index 0000000..c6b0f2d
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/URITemplateParser.java
@@ -0,0 +1,141 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+
+/**
+ * URITemplateParser to parse and get node of a URI expression.
+ */
+public class URITemplateParser {
+
+    private static final char[] operators = new char[] { '+', '.', '/', ';', '?', '&', '#' };
+
+    private Node syntaxTree;
+    private Node currentNode;
+
+    public Node parse(String template) throws URITemplateException {
+        if (!"/".equals(template) && template.endsWith("/")) {
+            template = template.substring(0, template.length() - 1);
+        }
+
+        boolean expression = false;
+        int startIndex = 0;
+        int maxIndex = template.length() - 1;
+
+        for (int pointerIndex = 0; pointerIndex < template.length(); pointerIndex++) {
+            char ch = template.charAt(pointerIndex);
+
+            switch (ch) {
+                case '{':
+                    if (!expression) {
+                        if (pointerIndex + 1 >= maxIndex) {
+                            throw new URITemplateException("Illegal open brace character");
+                        }
+
+                        expression = true;
+                        if (pointerIndex > startIndex) {
+                            addNode(new Literal(template.substring(startIndex, pointerIndex)));
+                            startIndex = pointerIndex + 1;
+                        } else if (template.charAt(pointerIndex - 1) != '}') {
+                            throw new URITemplateException("Illegal empty literal");
+                        } else {
+                            startIndex++;
+                        }
+                    } else {
+                        throw new URITemplateException("Already in expression");
+                    }
+                    break;
+
+                case '}':
+                    if (expression) {
+                        expression = false;
+                        if (pointerIndex > startIndex) {
+                            createExpressionNode(template.substring(startIndex, pointerIndex));
+                            startIndex = pointerIndex + 1;
+                        } else {
+                            throw new URITemplateException("Illegal empty expression");
+                        }
+                    } else {
+                        throw new URITemplateException("Illegal closing brace detected");
+                    }
+                    break;
+
+                default:
+                    if (pointerIndex == maxIndex) {
+                        String token = template.substring(startIndex);
+                        if (expression) {
+                            createExpressionNode(token);
+                        } else {
+                            addNode(new Literal(token));
+                        }
+                    }
+            }
+        }
+        return syntaxTree;
+    }
+
+    private void addNode(Node node) {
+        if (syntaxTree == null) {
+            syntaxTree = node;
+            currentNode = syntaxTree;
+        } else {
+            currentNode.setNext(node);
+            currentNode = node;
+        }
+    }
+
+    private void createExpressionNode(String expression) throws URITemplateException {
+        Node node = null;
+        if (isSimpleString(expression)) {
+            node = new SimpleStringExpression(expression);
+        }
+
+        if (expression.length() <= 1) {
+            throw new URITemplateException("Invalid template expression: {" + expression + "}");
+        }
+
+        if (expression.startsWith("#")) {
+            node = new FragmentExpression(expression.substring(1));
+        } else if (expression.startsWith("+")) {
+            node = new ReservedStringExpression(expression.substring(1));
+        } else if (expression.startsWith(".")) {
+            node = new LabelExpression(expression.substring(1));
+        } else if (expression.startsWith("/")) {
+            node = new PathSegmentExpression(expression.substring(1));
+        }
+
+        if (node != null) {
+            addNode(node);
+        } else {
+            throw new URITemplateException("Unsupported template expression: {" + expression + "}");
+        }
+    }
+
+    private boolean isSimpleString(String expression) {
+        for (char op : operators) {
+            if (expression.indexOf(op) == 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Variable.java b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Variable.java
new file mode 100644
index 0000000..c6ff465
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/java/org/wso2/carbon/gateway/internal/util/uri/parser/Variable.java
@@ -0,0 +1,72 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.wso2.carbon.gateway.internal.util.uri.parser;
+
+
+import org.wso2.carbon.gateway.internal.util.uri.URITemplateException;
+
+
+/**
+ * Variable representation.
+ */
+public class Variable {
+
+    private String name;
+    private int prefix = -1;
+
+    public Variable(String value) throws URITemplateException {
+        this.name = value;
+        for (int i = 0; i < value.length(); i++) {
+            char ch = value.charAt(i);
+            if (!isValid(value.charAt(i)) && ch != ':') {
+                throw new URITemplateException("Invalid character: '" + ch + "' in expression");
+            } else if (ch == ':') {
+                this.name = value.substring(0, i);
+                this.prefix = Integer.parseInt(value.substring(i + 1));
+                if (prefix <= 0) {
+                    throw new URITemplateException("Invalid variable prefix: " + prefix);
+                }
+                break;
+            }
+        }
+    }
+
+    private boolean isValid(char ch) {
+        return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
+                (ch >= '0' && ch <= '9') || ch == '.'  || ch == '-' || ch == '_');
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String modify(String value) {
+        if (prefix > 0 && prefix < value.length()) {
+            return value.substring(0, prefix);
+        }
+        return value;
+    }
+
+    public boolean checkModifier(String value) {
+        if (prefix > 0) {
+            return value.length() == prefix;
+        }
+        return true;
+    }
+}
diff --git a/carbon-gw/components/org.wso2.carbon.gateway/src/main/resources/org/wso2/carbon/gateway/xml/camel-spring.xsd b/carbon-gw/components/org.wso2.carbon.gateway/src/main/resources/org/wso2/carbon/gateway/xml/camel-spring.xsd
new file mode 100644
index 0000000..7a7c2d0
--- /dev/null
+++ b/carbon-gw/components/org.wso2.carbon.gateway/src/main/resources/org/wso2/carbon/gateway/xml/camel-spring.xsd
@@ -0,0 +1,6192 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://camel.apache.org/schema/spring" elementFormDefault="qualified" targetNamespace="http://camel.apache.org/schema/spring" version="1.0">
+
+    <xs:element name="aggregate" type="tns:aggregateDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Aggregates many messages into a single message</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="aop" type="tns:aopDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Does processing before and/or after the route is completed</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="avro" type="tns:avroDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Avro data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="barcode" type="tns:barcodeDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Barcode data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="base64" type="tns:base64DataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Base64 data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="batch-config" type="tns:batchResequencerConfig">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Configures batch-processing resequence eip.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="bean" type="tns:beanDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Calls a java bean</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="beanPostProcessor" type="tns:camelBeanPostProcessor"/>
+
+    <xs:element name="beanio" type="tns:beanioDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">BeanIO data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="bindy" type="tns:bindyDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Bindy data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="camelContext" type="tns:camelContextFactoryBean"/>
+
+    <xs:element name="castor" type="tns:castorDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Castor data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="choice" type="tns:choiceDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Routes messages based on a series of predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="circuitBreaker" type="tns:circuitBreakerLoadBalancerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Circuit break load balancer</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="constant" type="tns:constantExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For expressions and predicates using a constant</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="consumerTemplate" type="tns:camelConsumerTemplateFactoryBean"/>
+
+    <xs:element name="contextScan" type="tns:contextScanDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Scans for Java org.apache.camel.builder.RouteBuilder instances in the context org.apache.camel.spi.Registry.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="convertBodyTo" type="tns:convertBodyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Converts the message body to another type</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="crypto" type="tns:cryptoDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Crypto data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="csv" type="tns:csvDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">CSV data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="customDataFormat" type="tns:customDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Custom data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="customLoadBalancer" type="tns:customLoadBalancerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Custom load balancer</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="dataFormats" type="tns:dataFormatsDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To configure data formats</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="delay" type="tns:delayDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Delays processing for a specified length of time</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="delete" type="tns:deleteVerbDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Rest DELETE command</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="description" type="tns:descriptionDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To provide comments about the node.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="doCatch" type="tns:catchDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Catches exceptions as part of a try catch finally block</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="doFinally" type="tns:finallyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Path traversed when a try catch finally block exits</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="doTry" type="tns:tryDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Marks the beginning of a try catch finally block</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="dynamicRouter" type="tns:dynamicRouterDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Routes messages based on dynamic rules</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="el" type="tns:elExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For EL expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="endpoint" type="tns:camelEndpointFactoryBean"/>
+
+    <xs:element name="enrich" type="tns:enrichDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Enriches a message with data from a secondary resource</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="errorHandler" type="tns:errorHandlerDefinition"/>
+
+    <xs:element name="exchangeProperty" type="tns:exchangePropertyExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">An expression which extracts the named exchange property</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="export" type="tns:camelServiceExporterDefinition"/>
+
+    <xs:element name="expression" type="tns:expressionSubElementDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">A useful base class for an expression</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="expressionDefinition" type="tns:expression"/>
+
+    <xs:element name="failover" type="tns:failoverLoadBalancerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Failover load balancer</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="filter" type="tns:filterDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Filter out messages based using a predicate</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="flatpack" type="tns:flatpackDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Flatpack data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="from" type="tns:fromDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Act as a message source as input to a route</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="get" type="tns:getVerbDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Rest GET command</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="groovy" type="tns:groovyExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For Groovy expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="gzip" type="tns:gzipDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">GZip data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="head" type="tns:headVerbDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Rest HEAD command</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="header" type="tns:headerExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">An expression which extracts the named exchange header</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="hl7" type="tns:hl7DataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">HL7 data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="ical" type="tns:icalDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">iCal data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="idempotentConsumer" type="tns:idempotentConsumerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Filters out duplicate messages</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="inOnly" type="tns:inOnlyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Marks the exchange pattern for the route to one way</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="inOut" type="tns:inOutDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Marks the exchange pattern for the route to request/reply</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="intercept" type="tns:interceptDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Intercepts a message at each step in the route</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="interceptFrom" type="tns:interceptFromDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Intercepts incoming messages</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="interceptSendToEndpoint" type="tns:interceptSendToEndpointDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Intercepts messages being sent to an endpoint</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="javaScript" type="tns:javaScriptExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For JavaScript expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="jaxb" type="tns:jaxbDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">JAXB data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="jibx" type="tns:jibxDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">JiBX data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="jmxAgent" type="tns:camelJMXAgentDefinition"/>
+
+    <xs:element name="json" type="tns:jsonDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Json data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="jsonpath" type="tns:jsonPathExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For JSonPath expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="jxpath" type="tns:jxPathExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For JXPath expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="keyStoreParameters" type="tns:keyStoreParametersFactoryBean"/>
+
+    <xs:element name="language" type="tns:languageExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Represents a parameterised language expression which can support any language at runtime using the language attribute.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="loadBalance" type="tns:loadBalanceDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Balances message processing among a number of nodes</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="log" type="tns:logDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Logs the defined message to the logger</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="loop" type="tns:loopDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Processes a message multiple times</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="marshal" type="tns:marshalDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Marshals data into a specified format for transmission over a transport or component</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="method" type="tns:methodCallExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For expressions and predicates using a java bean (aka method call)</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="multicast" type="tns:multicastDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Routes the same message to multiple paths either sequentially or in parallel.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="mvel" type="tns:mvelExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For MVEL expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="ognl" type="tns:ognlExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For OGNL expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="onCompletion" type="tns:onCompletionDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Route to be executed when normal route processing completes</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="onException" type="tns:onExceptionDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Route to be executed when an exception is thrown</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="optimisticLockRetryPolicy" type="tns:optimisticLockRetryPolicyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To configure optimistic locking</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="otherwise" type="tns:otherwiseDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Route to be executed when all other choices evaluate to false</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="packageScan" type="tns:packageScanDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Scans for Java org.apache.camel.builder.RouteBuilder classes in java packages</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="pgp" type="tns:pgpDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">PGP data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="php" type="tns:phpExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For PHP expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="pipeline" type="tns:pipelineDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Routes the message to a sequence of processors.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="policy" type="tns:policyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Defines a policy the route will use</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="pollEnrich" type="tns:pollEnrichDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Enriches messages with data polled from a secondary resource</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="post" type="tns:postVerbDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Rest POST command</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="process" type="tns:processDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Calls a Camel processor.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="properties" type="tns:propertiesDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">A series of key value pair</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="propertiesFunction" type="tns:camelPropertyPlaceholderFunctionDefinition"/>
+
+    <xs:element name="property" type="tns:propertyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">A key value pair</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="propertyPlaceholder" type="tns:camelPropertyPlaceholderDefinition"/>
+
+    <xs:element name="protobuf" type="tns:protobufDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Google protobuf data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="proxy" type="tns:camelProxyFactoryDefinition"/>
+
+    <xs:element name="put" type="tns:putVerbDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Rest PUT command</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="python" type="tns:pythonExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For Python expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="random" type="tns:randomLoadBalancerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Random load balancer</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="recipientList" type="tns:recipientListDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Routes messages to a number of dynamically specified recipients (dynamic to)</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="redeliveryPolicy" type="tns:redeliveryPolicyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To configure re-delivery for error handling</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="redeliveryPolicyProfile" type="tns:camelRedeliveryPolicyFactoryBean"/>
+
+    <xs:element name="ref" type="tns:refExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For using a custom expression</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="removeHeader" type="tns:removeHeaderDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Removes a named header from the message</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="removeHeaders" type="tns:removeHeadersDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Removes message headers whose name matches a specified pattern</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="removeProperties" type="tns:removePropertiesDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Removes message exchange properties whose name matches a specified pattern</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="removeProperty" type="tns:removePropertyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Removes a named property from the message exchange</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="resequence" type="tns:resequenceDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Resequences (re-order) messages based on an expression</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="rest" type="tns:restDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Defines a rest service using the rest-dsl</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="restBinding" type="tns:restBindingDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To configure rest binding</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="restConfiguration" type="tns:restConfigurationDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To configure rest</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="restContext" type="tns:camelRestContextFactoryBean"/>
+
+    <xs:element name="restContextRef" type="tns:restContextRefDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To refer to an XML file with rest services defined using the rest-dsl</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="restProperty" type="tns:restPropertyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">A key value pair</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="rests" type="tns:restsDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">A series of rest services defined using the rest-dsl</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="rollback" type="tns:rollbackDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Forces a rollback by stopping routing the message</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="roundRobin" type="tns:roundRobinLoadBalancerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Round robin load balancer</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="route" type="tns:routeDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">A Camel route</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="routeBuilder" type="tns:routeBuilderDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To refer to a Java org.apache.camel.builder.RouteBuilder instance to use.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="routeContext" type="tns:camelRouteContextFactoryBean"/>
+
+    <xs:element name="routeContextRef" type="tns:routeContextRefDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To refer to an XML file with routes defined using the xml-dsl</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="routes" type="tns:routesDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">A series of Camel routes</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="routingSlip" type="tns:routingSlipDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Routes a message through a series of steps that are pre-determined (the slip)</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="rss" type="tns:rssDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">RSS data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="ruby" type="tns:rubyExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For Ruby expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="sample" type="tns:samplingDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Extract a sample of the messages passing through a route</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="secureRandomParameters" type="tns:secureRandomParametersFactoryBean"/>
+
+    <xs:element name="secureXML" type="tns:xmlSecurityDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">xml-security data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="serialization" type="tns:serializationDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Java Object Serialization data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="setBody" type="tns:setBodyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sets the contents of the message body</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="setExchangePattern" type="tns:setExchangePatternDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sets the exchange pattern on the message exchange</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="setFaultBody" type="tns:setFaultBodyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sets the contents of a fault message's body</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="setHeader" type="tns:setHeaderDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sets the value of a message header</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="setOutHeader" type="tns:setOutHeaderDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sets the value of a header on the outbound message</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="setProperty" type="tns:setPropertyDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sets a named property on the message exchange</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="simple" type="tns:simpleExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For expressions and predicates using the simple language</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="soapjaxb" type="tns:soapJaxbDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">SOAP data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="sort" type="tns:sortDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sorts the contents of the message</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="spel" type="tns:spELExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For Spring Expression Language (SpEL) expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="split" type="tns:splitDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Splits a single message into many sub-messages.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="sql" type="tns:sqlExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For SQL expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="sslContextParameters" type="tns:sslContextParametersFactoryBean"/>
+
+    <xs:element name="sticky" type="tns:stickyLoadBalancerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sticky load balancer</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="stop" type="tns:stopDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Stops the processing of the current message</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="stream-config" type="tns:streamResequencerConfig">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Configures stream-processing resequence eip.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="streamCaching" type="tns:camelStreamCachingStrategyDefinition"/>
+
+    <xs:element name="string" type="tns:stringDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Represents the String (text based) DataFormat</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="syslog" type="tns:syslogDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Syslog data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="template" type="tns:camelProducerTemplateFactoryBean"/>
+
+    <xs:element name="terser" type="tns:terserExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For HL7 terser expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="threadPool" type="tns:camelThreadPoolFactoryBean"/>
+
+    <xs:element name="threadPoolProfile" type="tns:threadPoolProfileDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To configure thread pools</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="threads" type="tns:threadsDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Specifies that all steps after this node are processed asynchronously</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="throttle" type="tns:throttleDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Controls the rate at which messages are passed to the next node in the route</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="throwException" type="tns:throwExceptionDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Throws an exception</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="tidyMarkup" type="tns:tidyMarkupDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Tidymark (wellformed HTML) data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="to" type="tns:toDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Sends the message to an endpoint</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="tokenize" type="tns:tokenizerExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For expressions and predicates using a body or header tokenizer.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="topic" type="tns:topicLoadBalancerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Topic load balancer</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="transacted" type="tns:transactedDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Enables transaction on the route</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="transform" type="tns:transformDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Transforms the message body based on an expression</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="univocity-csv" type="tns:uniVocityCsvDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">UniVocity CSV data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="univocity-fixed" type="tns:uniVocityFixedWidthDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">UniVocity fixed-width data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="univocity-header" type="tns:uniVocityHeader">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">To configure headers for UniVocity data formats.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="univocity-tsv" type="tns:uniVocityTsvDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">UniVocity TSV data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="unmarshal" type="tns:unmarshalDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Converts the message data received from the wire into a format that Apache Camel processors can consume</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="validate" type="tns:validateDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Validates a message based on an expression</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="verb" type="tns:verbDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Rest command</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="vtdxml" type="tns:vtdXmlExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For VTD-XML (fast and efficient XPath) expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="weighted" type="tns:weightedLoadBalancerDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Weighted load balancer</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="when" type="tns:whenDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Triggers a route when an expression evaluates to true</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="whenSkipSendToEndpoint" type="tns:whenSkipSendToEndpointDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Predicate to determine if the message should be sent or not to the endpoint when using interceptSentToEndpoint.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="wireTap" type="tns:wireTapDefinition">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">Routes a copy of a message (or creates a new message) to a secondary destination while continue routing the original message.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="xmlBeans" type="tns:xmlBeansDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">XMLBeans data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="xmljson" type="tns:xmlJsonDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">xml-json data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="xmlrpc" type="tns:xmlRpcDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">xml-rpc data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="xpath" type="tns:xPathExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For XPath expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="xquery" type="tns:xQueryExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For XQuery expressions and predicates</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="xstream" type="tns:xStreamDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">xstream data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="xtokenize" type="tns:xmlTokenizerExpression">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">For expressions and predicates using a body or header tokenizer.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="zip" type="tns:zipDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">zip data format (not for zip files)</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:element name="zipFile" type="tns:zipFileDataFormat">
+        <xs:annotation>
+            <xs:documentation xml:lang="en">zip-file data format</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+
+    <xs:complexType abstract="true" name="abstractCamelConsumerTemplateFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelFactoryBean">
+                <xs:sequence/>
+                <xs:attribute name="maximumCacheSize" type="xs:int"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractCamelFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+                <xs:attribute name="camelContextId" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="identifiedType">
+        <xs:sequence/>
+        <xs:attribute name="id" type="xs:ID">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the value of the id property.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractCamelContextFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractCamelEndpointFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelFactoryBean">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:property"/>
+                </xs:sequence>
+                <xs:attribute name="singleton" type="xs:boolean"/>
+                <xs:attribute name="uri" type="xs:string" use="required"/>
+                <xs:attribute name="pattern" type="tns:exchangePattern"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="propertyDefinition">
+        <xs:sequence/>
+        <xs:attribute name="key" type="xs:string" use="required">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Property key</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="value" type="xs:string" use="required">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Property value</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractCamelProducerTemplateFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelFactoryBean">
+                <xs:sequence/>
+                <xs:attribute name="defaultEndpoint" type="xs:string"/>
+                <xs:attribute name="maximumCacheSize" type="xs:int"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractCamelRedeliveryPolicyFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelFactoryBean">
+                <xs:sequence/>
+                <xs:attribute name="maximumRedeliveries" type="xs:string"/>
+                <xs:attribute name="redeliveryDelay" type="xs:string"/>
+                <xs:attribute name="asyncDelayedRedelivery" type="xs:string"/>
+                <xs:attribute name="backOffMultiplier" type="xs:string"/>
+                <xs:attribute name="useExponentialBackOff" type="xs:string"/>
+                <xs:attribute name="collisionAvoidanceFactor" type="xs:string"/>
+                <xs:attribute name="useCollisionAvoidance" type="xs:string"/>
+                <xs:attribute name="maximumRedeliveryDelay" type="xs:string"/>
+                <xs:attribute name="retriesExhaustedLogLevel" type="tns:loggingLevel"/>
+                <xs:attribute name="retryAttemptedLogLevel" type="tns:loggingLevel"/>
+                <xs:attribute name="logRetryAttempted" type="xs:string"/>
+                <xs:attribute name="logStackTrace" type="xs:string"/>
+                <xs:attribute name="logRetryStackTrace" type="xs:string"/>
+                <xs:attribute name="logHandled" type="xs:string"/>
+                <xs:attribute name="logContinued" type="xs:string"/>
+                <xs:attribute name="logExhausted" type="xs:string"/>
+                <xs:attribute name="logExhaustedMessageHistory" type="xs:string"/>
+                <xs:attribute name="disableRedelivery" type="xs:string"/>
+                <xs:attribute name="delayPattern" type="xs:string"/>
+                <xs:attribute name="allowRedeliveryWhileStopping" type="xs:string"/>
+                <xs:attribute name="exchangeFormatterRef" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractCamelThreadPoolFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelFactoryBean">
+                <xs:sequence/>
+                <xs:attribute name="poolSize" type="xs:string" use="required"/>
+                <xs:attribute name="maxPoolSize" type="xs:string"/>
+                <xs:attribute name="keepAliveTime" type="xs:string"/>
+                <xs:attribute name="timeUnit" type="xs:string"/>
+                <xs:attribute name="maxQueueSize" type="xs:string"/>
+                <xs:attribute name="allowCoreThreadTimeOut" type="xs:string"/>
+                <xs:attribute name="rejectedPolicy" type="tns:threadPoolRejectedPolicy"/>
+                <xs:attribute name="threadName" type="xs:string" use="required"/>
+                <xs:attribute name="scheduled" type="xs:boolean"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelJMXAgentDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+                <xs:attribute name="disabled" type="xs:string"/>
+                <xs:attribute name="onlyRegisterProcessorWithCustomId" type="xs:string"/>
+                <xs:attribute name="registryPort" type="xs:string"/>
+                <xs:attribute name="connectorPort" type="xs:string"/>
+                <xs:attribute name="mbeanServerDefaultDomain" type="xs:string"/>
+                <xs:attribute name="mbeanObjectDomainName" type="xs:string"/>
+                <xs:attribute name="serviceUrlPath" type="xs:string"/>
+                <xs:attribute name="createConnector" type="xs:string"/>
+                <xs:attribute name="usePlatformMBeanServer" type="xs:string"/>
+                <xs:attribute name="registerAlways" type="xs:string"/>
+                <xs:attribute name="registerNewRoutes" type="xs:string"/>
+                <xs:attribute name="statisticsLevel" type="xs:string"/>
+                <xs:attribute name="loadStatisticsEnabled" type="xs:string"/>
+                <xs:attribute name="includeHostName" type="xs:string"/>
+                <xs:attribute name="mask" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelPropertyPlaceholderDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:propertiesFunction"/>
+                </xs:sequence>
+                <xs:attribute name="location" type="xs:string" use="required"/>
+                <xs:attribute name="encoding" type="xs:string"/>
+                <xs:attribute name="cache" type="xs:boolean"/>
+                <xs:attribute name="ignoreMissingLocation" type="xs:boolean"/>
+                <xs:attribute name="propertiesResolverRef" type="xs:string"/>
+                <xs:attribute name="propertiesParserRef" type="xs:string"/>
+                <xs:attribute name="propertyPrefix" type="xs:string"/>
+                <xs:attribute name="propertySuffix" type="xs:string"/>
+                <xs:attribute name="fallbackToUnaugmentedProperty" type="xs:boolean"/>
+                <xs:attribute name="prefixToken" type="xs:string"/>
+                <xs:attribute name="suffixToken" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelPropertyPlaceholderFunctionDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string" use="required"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelProxyFactoryDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+                <xs:attribute name="serviceUrl" type="xs:string"/>
+                <xs:attribute name="serviceRef" type="xs:string"/>
+                <xs:attribute name="serviceInterface" type="xs:string"/>
+                <xs:attribute name="camelContextId" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelServiceExporterDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+                <xs:attribute name="uri" type="xs:string"/>
+                <xs:attribute name="serviceRef" type="xs:string"/>
+                <xs:attribute name="serviceInterface" type="xs:string"/>
+                <xs:attribute name="camelContextId" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelStreamCachingStrategyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+                <xs:attribute name="enabled" type="xs:string"/>
+                <xs:attribute name="spoolDirectory" type="xs:string"/>
+                <xs:attribute name="spoolChiper" type="xs:string"/>
+                <xs:attribute name="spoolThreshold" type="xs:string"/>
+                <xs:attribute name="spoolUsedHeapMemoryThreshold" type="xs:string"/>
+                <xs:attribute name="spoolUsedHeapMemoryLimit" type="xs:string"/>
+                <xs:attribute name="spoolRules" type="xs:string"/>
+                <xs:attribute name="bufferSize" type="xs:string"/>
+                <xs:attribute name="removeSpoolDirectoryWhenStopping" type="xs:string"/>
+                <xs:attribute name="statisticsEnabled" type="xs:string"/>
+                <xs:attribute name="anySpoolRules" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="patternBasedPackageScanFilter">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractJsseUtilFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelFactoryBean">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractKeyManagersParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractJsseUtilFactoryBean">
+                <xs:sequence/>
+                <xs:attribute name="keyPassword" type="xs:string"/>
+                <xs:attribute name="provider" type="xs:string"/>
+                <xs:attribute name="algorithm" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractKeyStoreParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractJsseUtilFactoryBean">
+                <xs:sequence/>
+                <xs:attribute name="type" type="xs:string"/>
+                <xs:attribute name="password" type="xs:string"/>
+                <xs:attribute name="provider" type="xs:string"/>
+                <xs:attribute name="resource" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractSecureRandomParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractJsseUtilFactoryBean">
+                <xs:sequence/>
+                <xs:attribute name="algorithm" type="xs:string" use="required"/>
+                <xs:attribute name="provider" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="abstractTrustManagersParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractJsseUtilFactoryBean">
+                <xs:sequence/>
+                <xs:attribute name="provider" type="xs:string"/>
+                <xs:attribute name="algorithm" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="cipherSuitesParameters">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="cipherSuite" nillable="true" type="xs:string"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="filterParameters">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="include" nillable="true" type="xs:string"/>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="exclude" nillable="true" type="xs:string"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="secureSocketProtocolsParameters">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="secureSocketProtocol" nillable="true" type="xs:string"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="aopDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:attribute name="beforeUri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Endpoint to call in AOP before.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="afterUri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Endpoint to call in AOP after. The difference between after and afterFinally is that afterFinally is invoked from a finally block so it will always be invoked no matter what eg also in case of an exception occur.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="afterFinallyUri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Endpoint to call in AOP after finally. The difference between after and afterFinally is that afterFinally is invoked from a finally block so it will always be invoked no matter what eg also in case of an exception occur.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="output">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="processorDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:optionalIdentifiedDefinition">
+                <xs:sequence/>
+                <xs:attribute name="inheritErrorHandler" type="xs:boolean"/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="optionalIdentifiedDefinition">
+        <xs:sequence>
+            <xs:element minOccurs="0" ref="tns:description"/>
+        </xs:sequence>
+        <xs:attribute name="customId" type="xs:boolean"/>
+        <xs:attribute name="id" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the id of this node</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType name="descriptionDefinition">
+        <xs:simpleContent>
+            <xs:extension base="xs:string">
+                <xs:attribute name="lang" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Language such as en for english.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="layoutX" type="xs:double">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Layout position X</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="layoutY" type="xs:double">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Layout position Y</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="layoutWidth" type="xs:double">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Layout width</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="layoutHeight" type="xs:double">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Layout height</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="aggregateDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:element name="correlationExpression" type="tns:expressionSubElementDefinition"/>
+                    <xs:element minOccurs="0" name="completionPredicate" type="tns:expressionSubElementDefinition"/>
+                    <xs:element minOccurs="0" name="completionTimeout" type="tns:expressionSubElementDefinition"/>
+                    <xs:element minOccurs="0" name="completionSize" type="tns:expressionSubElementDefinition"/>
+                    <xs:element minOccurs="0" ref="tns:optimisticLockRetryPolicy"/>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:attribute name="parallelProcessing" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">When aggregated are completed they are being send out of the aggregator. This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency. If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="optimisticLocking" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Turns on using optimistic locking which requires the aggregationRepository being used is supporting this by implementing org.apache.camel.spi.OptimisticLockingAggregationRepository.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If using parallelProcessing you can specify a custom thread pool to be used. In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="timeoutCheckerExecutorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If using either of the completionTimeout completionTimeoutExpression or completionInterval options a background thread is created to check for the completion for every aggregator. Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="aggregationRepositoryRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the custom aggregate repository to use Will by default use org.apache.camel.processor.aggregate.MemoryAggregationRepository</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">A reference to lookup the AggregationStrategy in the Registry. Configuring an AggregationStrategy is required and is used to merge the incoming Exchange with the existing already merged exchanges. At first call the oldExchange parameter is null. On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used for the very first aggregation. If this option is true then null values is used as the oldExchange (at the very first aggregation) when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="completionSize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the completion size which is the number of aggregated exchanges which would cause the aggregate to consider the group as complete and send out the aggregated exchange.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="completionInterval" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the completion interval which would cause the aggregate to consider the group as complete and send out the aggregated exchange.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="completionTimeout" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the completion timeout which would cause the aggregate to consider the group as complete and send out the aggregated exchange.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="completionFromBatchConsumer" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Enables the batch completion mode where we aggregate from a org.apache.camel.BatchConsumer and aggregate the total number of exchanges the org.apache.camel.BatchConsumer has reported as total by checking the exchange property link org.apache.camel.ExchangeBATCH_COMPLETE when its complete.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="groupExchanges" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Enables grouped exchanges so the aggregator will group all aggregated exchanges into a single combined Exchange holding all the aggregated exchanges in a java.util.List.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="eagerCheckCompletion" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Use eager completion checking which means that the completionPredicate will use the incoming Exchange. At opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreInvalidCorrelationKeys" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If a correlation key cannot be successfully evaluated it will be ignored by logging a DEBUG and then just ignore the incoming Exchange.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="closeCorrelationKeyOnCompletion" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Closes a correlation key when its complete. Any late received exchanges which has a correlation key that has been closed it will be defined and a org.apache.camel.processor.aggregate.ClosedCorrelationKeyException is thrown.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="discardOnCompletionTimeout" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Discards the aggregated message on completion timeout. This means on timeout the aggregated message is dropped and not sent out of the aggregator.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="forceCompletionOnStop" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Indicates to complete all current aggregated exchanges when the context is stopped</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="expressionSubElementDefinition">
+        <xs:choice>
+            <xs:element ref="tns:expressionDefinition"/>
+            <xs:element ref="tns:constant"/>
+            <xs:element ref="tns:el"/>
+            <xs:element ref="tns:exchangeProperty"/>
+            <xs:element ref="tns:groovy"/>
+            <xs:element ref="tns:header"/>
+            <xs:element ref="tns:jxpath"/>
+            <xs:element ref="tns:javaScript"/>
+            <xs:element ref="tns:jsonpath"/>
+            <xs:element ref="tns:language"/>
+            <xs:element ref="tns:method"/>
+            <xs:element ref="tns:mvel"/>
+            <xs:element ref="tns:ognl"/>
+            <xs:element ref="tns:php"/>
+            <xs:element ref="tns:python"/>
+            <xs:element ref="tns:ref"/>
+            <xs:element ref="tns:ruby"/>
+            <xs:element ref="tns:simple"/>
+            <xs:element ref="tns:spel"/>
+            <xs:element ref="tns:sql"/>
+            <xs:element ref="tns:terser"/>
+            <xs:element ref="tns:tokenize"/>
+            <xs:element ref="tns:vtdxml"/>
+            <xs:element ref="tns:xtokenize"/>
+            <xs:element ref="tns:xpath"/>
+            <xs:element ref="tns:xquery"/>
+        </xs:choice>
+    </xs:complexType>
+
+    <xs:complexType name="expression">
+        <xs:simpleContent>
+            <xs:extension base="xs:string">
+                <xs:attribute name="id" type="xs:ID">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the id of this node</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="trim" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to trim the value to remove leading and trailing whitespaces and line breaks</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="optimisticLockRetryPolicyDefinition">
+        <xs:sequence/>
+        <xs:attribute name="maximumRetries" type="xs:int">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the maximum number of retries</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="retryDelay" type="xs:long">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the delay in millis between retries</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="maximumRetryDelay" type="xs:long">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the upper value of retry in millis between retries when using exponential or random backoff</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="exponentialBackOff" type="xs:boolean">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Enable exponential backoff</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="randomBackOff" type="xs:boolean">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Enables random backoff</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType name="beanDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a reference to a bean to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="method" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the method name on the bean to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="beanType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the Class of the bean</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="cache" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Caches the bean lookup to avoid lookup up bean on every usage.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="multiParameterArray" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether the message body is an array type.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="noOutputDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="catchDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" name="exception" type="xs:string"/>
+                    <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
+                    <xs:element minOccurs="0" name="handled" type="tns:expressionSubElementDefinition"/>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="whenDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:expressionNode">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="expressionNode">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:choice>
+                        <xs:element ref="tns:expressionDefinition"/>
+                        <xs:element ref="tns:constant"/>
+                        <xs:element ref="tns:el"/>
+                        <xs:element ref="tns:exchangeProperty"/>
+                        <xs:element ref="tns:groovy"/>
+                        <xs:element ref="tns:header"/>
+                        <xs:element ref="tns:jxpath"/>
+                        <xs:element ref="tns:javaScript"/>
+                        <xs:element ref="tns:jsonpath"/>
+                        <xs:element ref="tns:language"/>
+                        <xs:element ref="tns:method"/>
+                        <xs:element ref="tns:mvel"/>
+                        <xs:element ref="tns:ognl"/>
+                        <xs:element ref="tns:php"/>
+                        <xs:element ref="tns:python"/>
+                        <xs:element ref="tns:ref"/>
+                        <xs:element ref="tns:ruby"/>
+                        <xs:element ref="tns:simple"/>
+                        <xs:element ref="tns:spel"/>
+                        <xs:element ref="tns:sql"/>
+                        <xs:element ref="tns:terser"/>
+                        <xs:element ref="tns:tokenize"/>
+                        <xs:element ref="tns:vtdxml"/>
+                        <xs:element ref="tns:xtokenize"/>
+                        <xs:element ref="tns:xpath"/>
+                        <xs:element ref="tns:xquery"/>
+                    </xs:choice>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="choiceDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                    </xs:choice>
+                    <xs:element minOccurs="0" ref="tns:otherwise"/>
+                </xs:sequence>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="otherwiseDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType final="extension restriction" name="constants">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="contextScanDefinition">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="excludes" type="xs:string"/>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="includes" type="xs:string"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="convertBodyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="type" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The java type to convert to</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="charset" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To use a specific charset when converting</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="dataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="delayDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:expressionNode">
+                <xs:sequence/>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a custom Thread Pool if asyncDelay has been enabled.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="asyncDelayed" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Enables asynchronous delay which means the thread will noy block while delaying.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="callerRunsWhenRejected" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="dynamicRouterDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:attribute name="uriDelimiter" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the uri delimiter to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Ignore the invalidate endpoint exception when try to create a producer with that endpoint</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="cacheSize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producers when using this recipient list when uris are reused.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="noOutputExpressionNode">
+        <xs:complexContent>
+            <xs:extension base="tns:expressionNode">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="enrichDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="uri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The endpoint uri for the external service to enrich from. You must use either uri or ref.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to the endpoint for the external service to enrich from. You must use either uri or ref.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to an AggregationStrategy to be used to merge the reply from the external service into a single outgoing message. By default Camel will use the reply from the external service as outgoing message.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="aggregateOnException" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was an exception thrown while trying to retrieve the data to enrich from the resource. Setting this option to true allows end users to control what to do if there was an exception in the aggregate method. For example to suppress the exception or set a custom message body etc.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType final="extension restriction" name="expressionNodeHelper">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="filterDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:expressionNode">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="finallyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="fromDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:optionalIdentifiedDefinition">
+                <xs:sequence/>
+                <xs:attribute name="uri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the URI of the endpoint to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the name of the endpoint within the registry (such as the Spring ApplicationContext or JNDI) to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="idempotentConsumerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:expressionNode">
+                <xs:sequence/>
+                <xs:attribute name="messageIdRepositoryRef" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the reference name of the message id repository</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="eager" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets whether to eagerly add the key to the idempotent repository or wait until the exchange is complete. Eager is default enabled.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipDuplicate" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets whether to skip duplicates or not. The default behavior is to skip duplicates. A duplicate message would have the Exchange property link org.apache.camel.ExchangeDUPLICATE_MESSAGE set to a link BooleanTRUE value. A none duplicate message will not have this property set.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="removeOnFailure" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets whether to remove or keep the key on failure. The default behavior is to remove the key on failure.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="inOnlyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:sendDefinition">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="sendDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="uri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the uri of the endpoint to send to.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the reference of the endpoint to send to.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="inOutDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:sendDefinition">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="interceptDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="interceptFromDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:interceptDefinition">
+                <xs:sequence/>
+                <xs:attribute name="uri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Intercept incoming messages from the uri or uri pattern. If this option is not configured then all incoming messages is intercepted.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="interceptSendToEndpointDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:attribute name="uri" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Intercept sending to the uri or uri pattern.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipSendToOriginalEndpoint" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If set to true then the message is not sent to the original endpoint. By default (false) the message is both intercepted and then sent to the original endpoint.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="loadBalanceDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:choice minOccurs="0">
+                        <xs:element ref="tns:failover"/>
+                        <xs:element ref="tns:random"/>
+                        <xs:element name="custom" type="tns:customLoadBalancerDefinition"/>
+                        <xs:element ref="tns:roundRobin"/>
+                        <xs:element ref="tns:sticky"/>
+                        <xs:element ref="tns:topic"/>
+                        <xs:element ref="tns:weighted"/>
+                        <xs:element ref="tns:circuitBreaker"/>
+                    </xs:choice>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="failoverLoadBalancerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:loadBalancer">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" name="exception" type="xs:string"/>
+                </xs:sequence>
+                <xs:attribute name="roundRobin" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the failover load balancer should operate in round robin mode or not. If not then it will always start from the first endpoint when a new message is to be processed. In other words it restart from the top for every message. If round robin is enabled then it keeps state and will continue with the next endpoint in a round robin fashion. When using round robin it will not stick to last known good endpoint it will always pick the next endpoint to use.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="maximumFailoverAttempts" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">A value to indicate after X failover attempts we should exhaust (give up). Use -1 to indicate never give up and continuously try to failover. Use 0 to never failover. And use e.g. 3 to failover at most 3 times before giving up. his option can be used whether or not roundRobin is enabled or not.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="loadBalancer">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="randomLoadBalancerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:loadBalancer">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="customLoadBalancerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:loadBalancer">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to the custom load balancer to lookup from the registry</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="roundRobinLoadBalancerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:loadBalancer">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="stickyLoadBalancerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:loadBalancer">
+                <xs:sequence>
+                    <xs:element name="correlationExpression" type="tns:expressionSubElementDefinition"/>
+                </xs:sequence>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="topicLoadBalancerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:loadBalancer">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="weightedLoadBalancerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:loadBalancer">
+                <xs:sequence/>
+                <xs:attribute name="roundRobin" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To enable round robin mode. By default the weighted distribution mode is used. The default value is false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="distributionRatio" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The distribution ratio is a delimited String consisting on integer weights separated by delimiters for example 235. The distributionRatio must match the number of endpoints and/or processors specified in the load balancer list.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="distributionRatioDelimiter" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Delimiter used to specify the distribution ratio. The default value is</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="circuitBreakerLoadBalancerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:loadBalancer">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" name="exception" type="xs:string"/>
+                </xs:sequence>
+                <xs:attribute name="halfOpenAfter" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The timeout in millis to use as threshold to move state from closed to half-open or open state</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="threshold" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Number of previous failed messages to use as threshold to move state from closed to half-open or open state</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="logDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="message" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the log message (uses simple language)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="loggingLevel" type="tns:loggingLevel">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the logging level. The default value is INFO</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="logName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the name of the logger</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="marker" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To use slf4j marker</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="loggerRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To refer to a custom logger instance to lookup from the registry.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="loopDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:expressionNode">
+                <xs:sequence/>
+                <xs:attribute name="copy" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If the copy attribute is true a copy of the input Exchange is used for each iteration. That means each iteration will start from a copy of the same message. By default loop will loop the same exchange all over so each iteration may have different message content.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="marshalDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence>
+                    <xs:choice minOccurs="0">
+                        <xs:element ref="tns:avro"/>
+                        <xs:element ref="tns:base64"/>
+                        <xs:element ref="tns:beanio"/>
+                        <xs:element ref="tns:bindy"/>
+                        <xs:element ref="tns:castor"/>
+                        <xs:element ref="tns:crypto"/>
+                        <xs:element ref="tns:csv"/>
+                        <xs:element name="custom" type="tns:customDataFormat"/>
+                        <xs:element ref="tns:flatpack"/>
+                        <xs:element ref="tns:gzip"/>
+                        <xs:element ref="tns:hl7"/>
+                        <xs:element ref="tns:ical"/>
+                        <xs:element ref="tns:jaxb"/>
+                        <xs:element ref="tns:jibx"/>
+                        <xs:element ref="tns:json"/>
+                        <xs:element ref="tns:protobuf"/>
+                        <xs:element ref="tns:rss"/>
+                        <xs:element ref="tns:secureXML"/>
+                        <xs:element ref="tns:serialization"/>
+                        <xs:element ref="tns:soapjaxb"/>
+                        <xs:element ref="tns:string"/>
+                        <xs:element ref="tns:syslog"/>
+                        <xs:element ref="tns:tidyMarkup"/>
+                        <xs:element ref="tns:univocity-csv"/>
+                        <xs:element ref="tns:univocity-fixed"/>
+                        <xs:element ref="tns:univocity-tsv"/>
+                        <xs:element ref="tns:xmlBeans"/>
+                        <xs:element ref="tns:xmljson"/>
+                        <xs:element ref="tns:xmlrpc"/>
+                        <xs:element ref="tns:xstream"/>
+                        <xs:element ref="tns:pgp"/>
+                        <xs:element ref="tns:zip"/>
+                        <xs:element ref="tns:zipFile"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To refer to a custom data format to use as marshaller</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="avroDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="instanceClassName" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Class name to use for marshal and unmarshalling</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="base64DataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="lineLength" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To specific a maximum line length for the encoded data. By default 76 is used.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="lineSeparator" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The line separators to use. By default \r\n is used.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="urlSafe" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Instead of emitting '' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode operations. Decoding seamlessly handles both modes. Is by default false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="beanioDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="mapping" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The BeanIO mapping file. Is by default loaded from the classpath. You can prefix with file: http: or classpath: to denote from where to load the mapping file.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="streamName" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The name of the stream to use.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreUnidentifiedRecords" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to ignore unidentified records.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreUnexpectedRecords" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to ignore unexpected records.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreInvalidRecords" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to ignore invalid records.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="encoding" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The charset to use. Is by default the JVM platform default charset.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="bindyDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="type" type="tns:bindyType" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to use csv fixed or key value pairs mode.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="packages">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The java package names to scan for model classes.</xs:documentation>
+                    </xs:annotation>
+                    <xs:simpleType>
+                        <xs:list itemType="xs:string"/>
+                    </xs:simpleType>
+                </xs:attribute>
+                <xs:attribute name="classType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of model class to use.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="locale" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To configure a default locale to use such as us for united states. To use the JVM platform default locale then use the name default</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="castorDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="mappingFile" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Path to a Castor mapping file to load from the classpath.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="validation" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether validation is turned on or off. Is by default true.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="encoding" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Encoding to use when marshalling an Object to XML. Is by default UTF-8</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="packages">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Add additional packages to Castor XmlContext</xs:documentation>
+                    </xs:annotation>
+                    <xs:simpleType>
+                        <xs:list itemType="xs:string"/>
+                    </xs:simpleType>
+                </xs:attribute>
+                <xs:attribute name="classes">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Add additional class names to Castor XmlContext</xs:documentation>
+                    </xs:annotation>
+                    <xs:simpleType>
+                        <xs:list itemType="xs:string"/>
+                    </xs:simpleType>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="cryptoDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="algorithm" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The JCE algorithm name indicating the cryptographic algorithm that will be used. Is by default DES/CBC/PKCS5Padding.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="cryptoProvider" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The name of the JCE Security Provider that should be used.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="keyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to the secret key to lookup from the register to use.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="initVectorRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a byte array containing the Initialization Vector that will be used to initialize the Cipher.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="algorithmParameterRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">A JCE AlgorithmParameterSpec used to initialize the Cipher. Will lookup the type using the given name as a java.security.spec.AlgorithmParameterSpec type.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="buffersize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The size of the buffer used in the signature process.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="macAlgorithm" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The JCE algorithm name indicating the Message Authentication algorithm.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="shouldAppendHMAC" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Flag indicating that a Message Authentication Code should be calculated and appended to the encrypted data.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="inline" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Flag indicating that the configured IV should be inlined into the encrypted data stream. Is by default false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="csvDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" name="header" type="xs:string"/>
+                </xs:sequence>
+                <xs:attribute name="formatRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The reference format to use it will be updated with the other format options the default value is CSVFormat.DEFAULT</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="formatName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The name of the format to use the default value is CSVFormat.DEFAULT</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="commentMarkerDisabled" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Disables the comment marker of the reference format.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="commentMarker" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the comment marker of the reference format.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="delimiter" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the delimiter to use. The default value is (comma)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="escapeDisabled" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Use for disabling using escape character</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="escape" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the escape character to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="headerDisabled" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Use for disabling headers</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="allowMissingColumnNames" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to allow missing column names.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreEmptyLines" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to ignore empty lines.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreSurroundingSpaces" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to ignore surrounding spaces</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="nullStringDisabled" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Used to disable null strings</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="nullString" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the null string</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="quoteDisabled" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Used to disable quotes</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="quote" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the quote which by default is</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="recordSeparatorDisabled" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Used for disabling record separator</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="recordSeparator" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the record separator (aka new line) which by default is \r\n (CRLF)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipHeaderRecord" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to skip the header record in the output</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="lazyLoad" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="useMaps" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="recordConverterRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a custom CsvRecordConverter to lookup from the registry to use.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="customDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Reference to the custom org.apache.camel.spi.DataFormat to lookup from the Camel registry.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="flatpackDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="parserFactoryRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">References to a custom parser factory to lookup in the registry</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="definition" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The flatpack pzmap configuration file. Can be omitted in simpler situations but its preferred to use the pzmap.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="fixed" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Delimited or fixed. Is by default false = delimited</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreFirstRecord" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether the first line is ignored for delimited files (for the column headers). Is by default true.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="textQualifier" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If the text is qualified with a char such as "</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="delimiter" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The delimiter char (could be ; or similar)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="allowShortLines" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Allows for lines to be shorter than expected and ignores the extra characters</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreExtraColumns" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Allows for lines to be longer than expected and ignores the extra characters.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="gzipDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="hl7DataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="validate" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to validate the HL7 message Is by default true.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="icalDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="validating" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to validate.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="jaxbDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="contextPath" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Package name where your JAXB classes are located.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="schema" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To validate against an existing schema. Your can use the prefix classpath: file: or http: to specify how the resource should by resolved. You can separate multiple schema files by using the '' character.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="prettyPrint" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To enable pretty printing output nicely formatted. Is by default false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreJAXBElement" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to ignore JAXBElement elements - only needed to be set to false in very special use-cases.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="mustBeJAXBElement" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether marhsalling must be java objects with JAXB annotations. And if not then it fails. This option can be set to false to relax that such as when the data is already in XML format.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="filterNonXmlChars" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To ignore non xml characheters and replace them with an empty space.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="encoding" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To overrule and use a specific encoding</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="fragment" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To turn on marshalling XML fragment trees. By default JAXB looks for XmlRootElement annotation on given class to operate on whole XML tree. This is useful but not always - sometimes generated code does not have XmlRootElement annotation sometimes you need unmarshall only part of tree. In that case you can use partial unmarshalling. To enable this behaviours you need set property partClass. Camel will pass this class to JAXB's unmarshaler.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="partClass" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of class used for fragment parsing. See more details at the fragment option.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="partNamespace" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">XML namespace to use for fragment parsing. See more details at the fragment option.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="namespacePrefixRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes such as ns2 ns3 ns4 etc. To control this mapping Camel allows you to refer to a map which contains the desired mapping.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="xmlStreamWriterWrapper" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To use a custom xml stream writer.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="schemaLocation" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To define the location of the schema</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="jibxDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="unmarshallClass" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Class name to use when unmarshalling from XML to Java.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="bindingName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To use a custom binding factory</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="jsonDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="prettyPrint" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To enable pretty printing output nicely formatted. Is by default false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="library" type="tns:jsonLibrary">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Which json library to use such. Is by default xstream</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="unmarshalTypeName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Class name of the java type to use when unarmshalling</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="jsonView" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">When marshalling a POJO to JSON you might want to exclude certain fields from the JSON output. With Jackson you can use JSON views to accomplish this. This option is to refer to the class which has JsonView annotations</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="include" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If you want to marshal a pojo to JSON and the pojo has some fields with null values. And you want to skip these null values you can set this option to NOT_NULL</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="allowJmsType" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="collectionTypeName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a custom collection type to lookup in the registry to use. This option should rarely be used but allows to use different collection types than java.util.Collection based as default.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="useList" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To unarmshal to a List of Map or a List of Pojo.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="enableJaxbAnnotationModule" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to enable the JAXB annotations module when using jackson. When enabled then JAXB annotations can be used by Jackson.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="moduleClassNames" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To use custom Jackson modules com.fasterxml.jackson.databind.Module specified as a String with FQN class names. Multiple classes can be separated by comma.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="moduleRefs" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To use custom Jackson modules referred from the Camel registry. Multiple modules can be separated by comma.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="enableFeatures" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature com.fasterxml.jackson.databind.DeserializationFeature or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="disableFeatures" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature com.fasterxml.jackson.databind.DeserializationFeature or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="protobufDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="instanceClass" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of class to use when unarmshalling</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="rssDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="xmlSecurityDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="xmlCipherAlgorithm" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The cipher algorithm to be used for encryption/decryption of the XML message content. The available choices are: XMLCipher.TRIPLEDES XMLCipher.AES_128 XMLCipher.AES_128_GCM XMLCipher.AES_192 XMLCipher.AES_192_GCM XMLCipher.AES_256 XMLCipher.AES_256_GCM XMLCipher.SEED_128 XMLCipher.CAMELLIA_128 XMLCipher.CAMELLIA_192 XMLCipher.CAMELLIA_256 The default value is MLCipher.TRIPLEDES</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="passPhrase" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">A String used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided. If no passPhrase is specified a default passPhrase is used. The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm. For example using TRIPLEDES the passPhase can be a Only another 24 Byte key</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="secureTag" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The XPath reference to the XML Element selected for encryption/decryption. If no tag is specified the entire payload is encrypted/decrypted.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="secureTagContents" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">A boolean value to specify whether the XML Element is to be encrypted or the contents of the XML Element false = Element Level true = Element Content Level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="keyCipherAlgorithm" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The cipher algorithm to be used for encryption/decryption of the asymmetric key. The available choices are: XMLCipher.RSA_v1dot5 XMLCipher.RSA_OAEP XMLCipher.RSA_OAEP_11 The default value is XMLCipher.RSA_OAEP</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="recipientKeyAlias" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The key alias to be used when retrieving the recipient's public or private key from a KeyStore when performing asymmetric key encryption or decryption.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="keyOrTrustStoreParametersId" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a KeyStore instance to lookup in the registry which is used for configuration options for creating and loading a KeyStore instance that represents the sender's trustStore or recipient's keyStore.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="keyPassword" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The password to be used for retrieving the private key from the KeyStore. This key is used for asymmetric decryption.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="digestAlgorithm" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The digest algorithm to use with the RSA OAEP algorithm. The available choices are: XMLCipher.SHA1 XMLCipher.SHA256 XMLCipher.SHA512 The default value is XMLCipher.SHA1</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="mgfAlgorithm" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The MGF Algorithm to use with the RSA OAEP algorithm. The available choices are: EncryptionConstants.MGF1_SHA1 EncryptionConstants.MGF1_SHA256 EncryptionConstants.MGF1_SHA512 The default value is EncryptionConstants.MGF1_SHA1</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="addKeyValueForEncryptedKey" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to add the public key used to encrypt the session key as a KeyValue in the EncryptedKey structure or not.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="serializationDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="soapJaxbDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="contextPath" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Package name where your JAXB classes are located.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="encoding" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To overrule and use a specific encoding</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="elementNameStrategyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to an element strategy to lookup from the registry. An element name strategy is used for two purposes. The first is to find a xml element name for a given object and soap action when marshaling the object into a SOAP message. The second is to find an Exception class for a given soap fault name. The following three element strategy class name is provided out of the box. QNameStrategy - Uses a fixed qName that is configured on instantiation. Exception lookup is not supported TypeNameStrategy - Uses the name and namespace from the XMLType annotation of the given type. If no namespace is set then package-info is used. Exception lookup is not supported ServiceInterfaceStrategy - Uses information from a webservice interface to determine the type name and to find the exception class for a SOAP fault All three classes is located in the package name org.apache.camel.dataformat.soap.name If you have generated the web service stub code with cxf-codegen or a similar tool then you probably will want to use the ServiceInterfaceStrategy. In the case you have no annotated service interface you should use QNameStrategy or TypeNameStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="version" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">SOAP version should either be 1.1 or 1.2. Is by default 1.1</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="namespacePrefixRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes such as ns2 ns3 ns4 etc. To control this mapping Camel allows you to refer to a map which contains the desired mapping.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="schema" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To validate against an existing schema. Your can use the prefix classpath: file: or http: to specify how the resource should by resolved. You can separate multiple schema files by using the '' character.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="stringDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="charset" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets an encoding to use. Will by default use the JVM platform default charset.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="syslogDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="tidyMarkupDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="dataObjectType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">What data type to unmarshal as can either be org.w3c.dom.Node or java.lang.String. Is by default org.w3c.dom.Node</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="uniVocityCsvDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:uniVocityAbstractDataFormat">
+                <xs:sequence/>
+                <xs:attribute name="quoteAllFields" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not all values must be quoted when writing them.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="quote" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The quote symbol.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="quoteEscape" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The quote escape symbol</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="delimiter" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The delimiter of values</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="uniVocityAbstractDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:univocity-header"/>
+                </xs:sequence>
+                <xs:attribute name="nullValue" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The string representation of a null value. The default value is null</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipEmptyLines" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the empty lines must be ignored. The default value is true</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreTrailingWhitespaces" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the trailing white spaces must ignored. The default value is true</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreLeadingWhitespaces" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the leading white spaces must be ignored. The default value is true</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="headersDisabled" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the headers are disabled. When defined this option explicitly sets the headers as null which indicates that there is no header. The default value is false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="headerExtractionEnabled" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the header must be read in the first line of the test document The default value is false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="numberOfRecordsToRead" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The maximum number of record to read.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="emptyValue" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The String representation of an empty value</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="lineSeparator" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The line separator of the files The default value is to use the JVM platform line separator</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="normalizedLineSeparator" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The normalized line separator of the files The default value is \n</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="comment" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The comment symbol. The default value is</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="lazyLoad" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one. The default value is false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="asMap" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected). The default value is false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="uniVocityHeader">
+        <xs:simpleContent>
+            <xs:extension base="xs:string">
+                <xs:attribute name="length" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Header length</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="uniVocityFixedWidthDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:uniVocityAbstractDataFormat">
+                <xs:sequence/>
+                <xs:attribute name="skipTrailingCharsUntilNewline" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the trailing characters until new line must be ignored. The default value is false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="recordEndsOnNewline" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the record ends on new line. The default value is false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="padding" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The padding character. The default value is a space</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="uniVocityTsvDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:uniVocityAbstractDataFormat">
+                <xs:sequence/>
+                <xs:attribute name="escapeChar" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The escape character.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="xmlBeansDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="prettyPrint" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To enable pretty printing output nicely formatted. Is by default false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="xmlJsonDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="encoding" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the encoding. Used for unmarshalling (JSON to XML conversion).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="elementName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Specifies the name of the XML elements representing each array element. Used for unmarshalling (JSON to XML conversion).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="arrayName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Specifies the name of the top-level XML element. Used for unmarshalling (JSON to XML conversion). For example when converting 1 2 3 it will be output by default as 123. By setting this option or rootName you can alter the name of element 'a'.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="forceTopLevelObject" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Determines whether the resulting JSON will start off with a top-most element whose name matches the XML root element. Used for marshalling (XML to JSon conversion). If disabled XML string 12 turns into 'x: '1' 'y': '2' . Otherwise it turns into 'a': 'x: '1' 'y': '2' .</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="namespaceLenient" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Flag to be tolerant to incomplete namespace prefixes. Used for unmarshalling (JSON to XML conversion). In most cases json-lib automatically changes this flag at runtime to match the processing.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="rootName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Specifies the name of the top-level element. Used for unmarshalling (JSON to XML conversion). If not set json-lib will use arrayName or objectName (default value: 'o' at the current time it is not configurable in this data format). If set to 'root' the JSON string 'x': 'value1' 'y' : 'value2' would turn into value1value2 otherwise the 'root' element would be named 'o'.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipWhitespace" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Determines whether white spaces between XML elements will be regarded as text values or disregarded. Used for marshalling (XML to JSon conversion).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="trimSpaces" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Determines whether leading and trailing white spaces will be omitted from String values. Used for marshalling (XML to JSon conversion).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipNamespaces" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Signals whether namespaces should be ignored. By default they will be added to the JSON output using xmlns elements. Used for marshalling (XML to JSon conversion).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="removeNamespacePrefixes" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Removes the namespace prefixes from XML qualified elements so that the resulting JSON string does not contain them. Used for marshalling (XML to JSon conversion).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="expandableProperties">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">With expandable properties JSON array elements are converted to XML as a sequence of repetitive XML elements with the local name equal to the JSON key for example: number: 123 normally converted to: 123 (where e can be modified by setting elementName) would instead translate to 123 if number is set as an expandable property Used for unmarshalling (JSON to XML conversion).</xs:documentation>
+                    </xs:annotation>
+                    <xs:simpleType>
+                        <xs:list itemType="xs:string"/>
+                    </xs:simpleType>
+                </xs:attribute>
+                <xs:attribute name="typeHints" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Adds type hints to the resulting XML to aid conversion back to JSON. Used for unmarshalling (JSON to XML conversion).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="xmlRpcDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="request" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to unmarshal request or response Is by default false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="xStreamDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence>
+                    <xs:element minOccurs="0" name="converters" type="tns:converterList"/>
+                    <xs:element minOccurs="0" name="aliases" type="tns:aliasList"/>
+                    <xs:element minOccurs="0" name="omitFields" type="tns:omitFieldList"/>
+                    <xs:element minOccurs="0" name="implicitCollections" type="tns:implicitCollectionList"/>
+                </xs:sequence>
+                <xs:attribute name="encoding" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the encoding to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="driver" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To use a custom XStream driver. The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="driverRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To refer to a custom XStream driver to lookup in the registry. The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="mode" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Mode for dealing with duplicate references The possible values are: NO_REFERENCES ID_REFERENCES XPATH_RELATIVE_REFERENCES XPATH_ABSOLUTE_REFERENCES SINGLE_NODE_XPATH_RELATIVE_REFERENCES SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="converterList">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="converter" type="tns:converterEntry"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="converterEntry">
+        <xs:sequence/>
+        <xs:attribute name="class" type="xs:string"/>
+    </xs:complexType>
+
+    <xs:complexType name="aliasList">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="alias" type="tns:aliasEntry"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="aliasEntry">
+        <xs:sequence/>
+        <xs:attribute name="name" type="xs:string"/>
+        <xs:attribute name="class" type="xs:string"/>
+    </xs:complexType>
+
+    <xs:complexType name="omitFieldList">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="omitField" type="tns:omitFieldEntry"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="omitFieldEntry">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="field" type="xs:string"/>
+        </xs:sequence>
+        <xs:attribute name="class" type="xs:string"/>
+    </xs:complexType>
+
+    <xs:complexType name="implicitCollectionList">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="class" type="tns:implicitCollectionEntry"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="implicitCollectionEntry">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="field" type="xs:string"/>
+        </xs:sequence>
+        <xs:attribute name="name" type="xs:string"/>
+    </xs:complexType>
+
+    <xs:complexType name="pgpDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="keyUserid" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The user ID of the key in the PGP keyring used during encryption. Can also be only a part of a user ID. For example if the user ID is Test User then you can use the part Test User or to address the user ID.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="signatureKeyUserid" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">User ID of the key in the PGP keyring used for signing (during encryption) or signature verification (during decryption). During the signature verification process the specified User ID restricts the public keys from the public keyring which can be used for the verification. If no User ID is specified for the signature verficiation then any public key in the public keyring can be used for the verification. Can also be only a part of a user ID. For example if the user ID is Test User then you can use the part Test User or to address the User ID.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="password" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Password used when opening the private key (not used for encryption).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="signaturePassword" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Password used when opening the private key used for signing (during encryption).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="keyFileName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Filename of the keyring; must be accessible as a classpath resource (but you can specify a location in the file system by using the file: prefix).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="signatureKeyFileName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Filename of the keyring to use for signing (during encryption) or for signature verification (during decryption); must be accessible as a classpath resource (but you can specify a location in the file system by using the file: prefix).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="signatureKeyRing" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Keyring used for signing/verifying as byte array. You can not set the signatureKeyFileName and signatureKeyRing at the same time.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="armored" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">This option will cause PGP to base64 encode the encrypted text making it available for copy/paste etc.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="integrity" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Adds an integrity check/sign into the encryption file. The default value is true.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="provider" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Java Cryptography Extension (JCE) provider default is Bouncy Castle (BC). Alternatively you can use for example the IAIK JCE provider; in this case the provider must be registered beforehand and the Bouncy Castle provider must not be registered beforehand. The Sun JCE provider does not work.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="algorithm" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Symmetric key encryption algorithm; possible values are defined in org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags; for example 2 (= TRIPLE DES) 3 (= CAST5) 4 (= BLOWFISH) 6 (= DES) 7 (= AES_128). Only relevant for encrypting.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="compressionAlgorithm" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Compression algorithm; possible values are defined in org.bouncycastle.bcpg.CompressionAlgorithmTags; for example 0 (= UNCOMPRESSED) 1 (= ZIP) 2 (= ZLIB) 3 (= BZIP2). Only relevant for encrypting.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="hashAlgorithm" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Signature hash algorithm; possible values are defined in org.bouncycastle.bcpg.HashAlgorithmTags; for example 2 (= SHA1) 8 (= SHA256) 9 (= SHA384) 10 (= SHA512) 11 (=SHA224). Only relevant for signing.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="signatureVerificationOption" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Controls the behavior for verifying the signature during unmarshaling. There are 4 values possible: optional: The PGP message may or may not contain signatures; if it does contain signatures then a signature verification is executed. required: The PGP message must contain at least one signature; if this is not the case an exception (PGPException) is thrown. A signature verification is executed. ignore: Contained signatures in the PGP message are ignored; no signature verification is executed. no_signature_allowed: The PGP message must not contain a signature; otherwise an exception (PGPException) is thrown.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="zipDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="compressionLevel" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To specify a specific compression between 0-9. -1 is default compression 0 is no compression and 9 is best compression.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="zipFileDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="usingIterator" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If the zip file has more then one entry the setting this option to true allows to work with the splitter EIP to split the data using an iterator in a streaming mode.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType final="extension restriction" name="modelHelper">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="multicastDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:attribute name="parallelProcessing" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then sending messages to the multicasts occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only the sending and processing the replies from the multicasts which happens concurrently.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to an AggregationStrategy to be used to assemble the replies from the multicasts into a single outgoing message from the Multicast. By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="streaming" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as defined by the multicast.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="stopOnException" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the multicast will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="timeout" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a total timeout specified in millis when using parallel processing. If the Multicast hasn't been able to send and process all replies within the given timeframe then the timeout triggers and the Multicast breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="onPrepareRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="shareUnitOfWork" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Multicast will by default not share unit of work between the parent exchange and each multicasted exchange. This means each sub exchange has its own individual unit of work.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="parallelAggregate" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="onCompletionDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:attribute name="mode" type="tns:onCompletionMode">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the on completion mode. The default value is AfterConsumer</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="onCompleteOnly" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Will only synchronize when the org.apache.camel.Exchange completed successfully (no errors).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="onFailureOnly" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Will only synchronize when the org.apache.camel.Exchange ended with failure (exception or FAULT message).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="parallelProcessing" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then the on completion process will run asynchronously by a separate thread from a thread pool. By default this is false meaning the on completion process will run synchronously using the same caller thread as from the route.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="useOriginalMessage" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Will use the original input body when an org.apache.camel.Exchange for this on completion. By default this feature is off.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="onExceptionDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" name="exception" type="xs:string"/>
+                    <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
+                    <xs:element minOccurs="0" name="retryWhile" type="tns:expressionSubElementDefinition"/>
+                    <xs:element minOccurs="0" ref="tns:redeliveryPolicy"/>
+                    <xs:element minOccurs="0" name="handled" type="tns:expressionSubElementDefinition"/>
+                    <xs:element minOccurs="0" name="continued" type="tns:expressionSubElementDefinition"/>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:attribute name="redeliveryPolicyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a reference to a RedeliveryPolicy to lookup in the org.apache.camel.spi.Registry to be used.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="onRedeliveryRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="useOriginalMessage" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Will use the original input message when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN body we use the original IN body instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN body. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN body is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. By default this feature is off.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="redeliveryPolicyDefinition">
+        <xs:sequence/>
+        <xs:attribute name="maximumRedeliveries" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the maximum redeliveries x = redeliver at most x times 0 = no redeliveries -1 = redeliver forever</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="redeliveryDelay" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the initial redelivery delay</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="asyncDelayedRedelivery" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Allow synchronous delayed redelivery.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="backOffMultiplier" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the back off multiplier</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="useExponentialBackOff" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Turn on exponential backk off</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="collisionAvoidanceFactor" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the collision avoidance factor</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="useCollisionAvoidance" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Turn on collision avoidance.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="maximumRedeliveryDelay" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the maximum delay between redelivery</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="retriesExhaustedLogLevel" type="tns:loggingLevel">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the logging level to use when retries has exhausted</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="retryAttemptedLogLevel" type="tns:loggingLevel">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the logging level to use for logging retry attempts</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="logRetryAttempted" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets whether retry attempts should be logged or not. Can be used to include or reduce verbose.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="logStackTrace" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets whether stack traces should be logged. Can be used to include or reduce verbose.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="logRetryStackTrace" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets whether stack traces should be logged when an retry attempt failed. Can be used to include or reduce verbose.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="logHandled" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets whether handled exceptions should be logged or not. Can be used to include or reduce verbose.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="logNewException" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets whether new exceptions should be logged or not. Can be used to include or reduce verbose. A new exception is an exception that was thrown while handling a previous exception.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="logContinued" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets whether continued exceptions should be logged or not. Can be used to include or reduce verbose.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="logExhausted" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets whether exhausted exceptions should be logged or not. Can be used to include or reduce verbose.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="logExhaustedMessageHistory" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets whether exhausted exceptions should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="disableRedelivery" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Disables redelivery (same as setting maximum redeliveries to 0)</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="delayPattern" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the delay pattern with delay intervals.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="allowRedeliveryWhileStopping" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="exchangeFormatterRef" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the reference of the instance of org.apache.camel.spi.ExchangeFormatter to generate the log message from exchange.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType name="packageScanDefinition">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" name="package" type="xs:string"/>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="excludes" type="xs:string"/>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="includes" type="xs:string"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="pipelineDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="policyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a reference to use for lookup the policy in the registry.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="pollEnrichDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="uri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The endpoint uri for the external service to poll enrich from. You must use either uri or ref.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to the endpoint for the external service to poll enrich from. You must use either uri or ref.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="timeout" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Timeout in millis when polling from the external service. The timeout has influence about the poll enrich behavior. It basically operations in three different modes: negative value - Waits until a message is available and then returns it. Warning that this method could block indefinitely if no messages are available. 0 - Attempts to receive a message exchange immediately without waiting and returning null if a message exchange is not available yet. positive value - Attempts to receive a message exchange waiting up to the given timeout to expire if a message is not yet available. Returns null if timed out The default value is -1 and therefore the method could block indefinitely and therefore its recommended to use a timeout value</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to an AggregationStrategy to be used to merge the reply from the external service into a single outgoing message. By default Camel will use the reply from the external service as outgoing message.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="aggregateOnException" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was an exception thrown while trying to retrieve the data to enrich from the resource. Setting this option to true allows end users to control what to do if there was an exception in the aggregate method. For example to suppress the exception or set a custom message body etc.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="processDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Reference to the Processor to lookup in the registry to use.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType final="extension restriction" name="processorDefinitionHelper">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="propertiesDefinition">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:property"/>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="recipientListDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:attribute name="delimiter" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Delimiter used if the Expression returned multiple endpoints. Can be turned off using the value false. The default value is</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="parallelProcessing" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then sending messages to the recipients occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only the sending and processing the replies from the recipients which happens concurrently.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a reference to the AggregationStrategy to be used to assemble the replies from the recipients into a single outgoing message from the RecipientList. By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="stopOnException" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the recipient list will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Ignore the invalidate endpoint exception when try to create a producer with that endpoint</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="streaming" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as defined by the recipient list.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="timeout" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a total timeout specified in millis when using parallel processing. If the Recipient List hasn't been able to send and process all replies within the given timeframe then the timeout triggers and the Recipient List breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="onPrepareRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="shareUnitOfWork" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Recipient List will by default not share unit of work between the parent exchange and each recipient exchange. This means each sub exchange has its own individual unit of work.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="cacheSize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producers when using this recipient list when uris are reused.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="parallelAggregate" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="removeHeaderDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="headerName" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of header to remove</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="removeHeadersDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="pattern" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name or pattern of headers to remove</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="excludePattern" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name or patter of headers to not remove</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="removePropertiesDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="pattern" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name or pattern of properties to remove</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="excludePattern" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name or pattern of properties to not remove</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="removePropertyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="propertyName" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of property to remove</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="resequenceDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:choice minOccurs="0">
+                        <xs:element ref="tns:batch-config"/>
+                        <xs:element ref="tns:stream-config"/>
+                    </xs:choice>
+                    <xs:choice>
+                        <xs:element ref="tns:expressionDefinition"/>
+                        <xs:element ref="tns:constant"/>
+                        <xs:element ref="tns:el"/>
+                        <xs:element ref="tns:exchangeProperty"/>
+                        <xs:element ref="tns:groovy"/>
+                        <xs:element ref="tns:header"/>
+                        <xs:element ref="tns:jxpath"/>
+                        <xs:element ref="tns:javaScript"/>
+                        <xs:element ref="tns:jsonpath"/>
+                        <xs:element ref="tns:language"/>
+                        <xs:element ref="tns:method"/>
+                        <xs:element ref="tns:mvel"/>
+                        <xs:element ref="tns:ognl"/>
+                        <xs:element ref="tns:php"/>
+                        <xs:element ref="tns:python"/>
+                        <xs:element ref="tns:ref"/>
+                        <xs:element ref="tns:ruby"/>
+                        <xs:element ref="tns:simple"/>
+                        <xs:element ref="tns:spel"/>
+                        <xs:element ref="tns:sql"/>
+                        <xs:element ref="tns:terser"/>
+                        <xs:element ref="tns:tokenize"/>
+                        <xs:element ref="tns:vtdxml"/>
+                        <xs:element ref="tns:xtokenize"/>
+                        <xs:element ref="tns:xpath"/>
+                        <xs:element ref="tns:xquery"/>
+                    </xs:choice>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="batchResequencerConfig">
+        <xs:complexContent>
+            <xs:extension base="tns:resequencerConfig">
+                <xs:sequence/>
+                <xs:attribute name="batchSize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the size of the batch to be re-ordered. The default size is 100.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="batchTimeout" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the timeout for collecting elements to be re-ordered. The default timeout is 1000 msec.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="allowDuplicates" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to allow duplicates.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="reverse" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to reverse the ordering.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreInvalidExchanges" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to ignore invalid exchanges</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="resequencerConfig">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="streamResequencerConfig">
+        <xs:complexContent>
+            <xs:extension base="tns:resequencerConfig">
+                <xs:sequence/>
+                <xs:attribute name="capacity" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the capacity of the resequencer's inbound queue.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="timeout" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets minimum time to wait for missing elements (messages).</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreInvalidExchanges" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to ignore invalid exchanges</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="comparatorRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To use a custom comparator</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="rejectOld" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If true throws an exception when messages older than the last delivered message are processed</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="restContextRefDefinition">
+        <xs:sequence/>
+        <xs:attribute name="ref" type="xs:string" use="required">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Reference to the rest-dsl</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType final="extension restriction" name="restContextRefDefinitionHelper">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="rollbackDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="markRollbackOnly" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Mark the transaction for rollback only (cannot be overruled to commit)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="markRollbackOnlyLast" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Mark only last sub transaction for rollback only. When using sub transactions (if the transaction manager support this)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="message" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Message to use in rollback exception</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="routeBuilderDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Reference to the route builder instance</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="routeContextRefDefinition">
+        <xs:sequence/>
+        <xs:attribute name="ref" type="xs:string" use="required">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Reference to the routes in the xml dsl</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType final="extension restriction" name="routeContextRefDefinitionHelper">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="routeDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:processorDefinition">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:from"/>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:aop"/>
+                        <xs:element ref="tns:aggregate"/>
+                        <xs:element ref="tns:bean"/>
+                        <xs:element ref="tns:doCatch"/>
+                        <xs:element ref="tns:when"/>
+                        <xs:element ref="tns:choice"/>
+                        <xs:element ref="tns:otherwise"/>
+                        <xs:element ref="tns:convertBodyTo"/>
+                        <xs:element ref="tns:delay"/>
+                        <xs:element ref="tns:dynamicRouter"/>
+                        <xs:element ref="tns:enrich"/>
+                        <xs:element ref="tns:filter"/>
+                        <xs:element ref="tns:doFinally"/>
+                        <xs:element ref="tns:idempotentConsumer"/>
+                        <xs:element ref="tns:inOnly"/>
+                        <xs:element ref="tns:inOut"/>
+                        <xs:element ref="tns:intercept"/>
+                        <xs:element ref="tns:interceptFrom"/>
+                        <xs:element ref="tns:interceptSendToEndpoint"/>
+                        <xs:element ref="tns:loadBalance"/>
+                        <xs:element ref="tns:log"/>
+                        <xs:element ref="tns:loop"/>
+                        <xs:element ref="tns:marshal"/>
+                        <xs:element ref="tns:multicast"/>
+                        <xs:element ref="tns:onCompletion"/>
+                        <xs:element ref="tns:onException"/>
+                        <xs:element ref="tns:pipeline"/>
+                        <xs:element ref="tns:policy"/>
+                        <xs:element ref="tns:pollEnrich"/>
+                        <xs:element ref="tns:process"/>
+                        <xs:element ref="tns:recipientList"/>
+                        <xs:element ref="tns:removeHeader"/>
+                        <xs:element ref="tns:removeHeaders"/>
+                        <xs:element ref="tns:removeProperties"/>
+                        <xs:element ref="tns:removeProperty"/>
+                        <xs:element ref="tns:resequence"/>
+                        <xs:element ref="tns:rollback"/>
+                        <xs:element ref="tns:route"/>
+                        <xs:element ref="tns:routingSlip"/>
+                        <xs:element ref="tns:sample"/>
+                        <xs:element ref="tns:setBody"/>
+                        <xs:element ref="tns:setExchangePattern"/>
+                        <xs:element ref="tns:setFaultBody"/>
+                        <xs:element ref="tns:setHeader"/>
+                        <xs:element ref="tns:setOutHeader"/>
+                        <xs:element ref="tns:setProperty"/>
+                        <xs:element ref="tns:sort"/>
+                        <xs:element ref="tns:split"/>
+                        <xs:element ref="tns:stop"/>
+                        <xs:element ref="tns:threads"/>
+                        <xs:element ref="tns:throttle"/>
+                        <xs:element ref="tns:throwException"/>
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:transacted"/>
+                        <xs:element ref="tns:transform"/>
+                        <xs:element ref="tns:doTry"/>
+                        <xs:element ref="tns:unmarshal"/>
+                        <xs:element ref="tns:validate"/>
+                        <xs:element ref="tns:whenSkipSendToEndpoint"/>
+                        <xs:element ref="tns:wireTap"/>
+                        <xs:element ref="tns:restBinding"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:attribute name="autoStartup" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to auto start this route</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="delayer" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to slow down processing messages by a given delay in msec.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="errorHandlerRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the bean ref name of the error handler builder to use on this route</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="group" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The group that this route belongs to; could be the name of the RouteBuilder class or be explicitly configured in the XML. May be null.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="handleFault" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether handle fault is enabled on this route.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="messageHistory" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether message history is enabled on this route.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="rest" type="xs:boolean"/>
+                <xs:attribute name="routePolicyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Reference to custom org.apache.camel.spi.RoutePolicy to use by the route. Multiple policies can be configured by separating values using comma.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="shutdownRoute" type="tns:shutdownRoute">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To control how to shutdown the route.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="shutdownRunningTask" type="tns:shutdownRunningTask">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To control how to shutdown the route.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="startupOrder" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To configure the ordering of the routes being started</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="streamCache" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether stream caching is enabled on this route.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="trace" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether tracing is enabled on this route.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType final="extension restriction" name="routeDefinitionHelper">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="routesDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:optionalIdentifiedDefinition">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:route"/>
+                </xs:sequence>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="routingSlipDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:attribute name="uriDelimiter" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the uri delimiter to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Ignore the invalidate endpoint exception when try to create a producer with that endpoint</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="cacheSize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producers when using this recipient list when uris are reused.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="samplingDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:attribute name="samplePeriod" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the sample period during which only a single Exchange will pass through.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="messageFrequency" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the sample message count which only a single Exchange will pass through after this many received.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="units" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the time units for the sample period defaulting to seconds.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="setBodyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="setExchangePatternDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="pattern" type="tns:exchangePattern" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the new exchange pattern of the Exchange to be used from this point forward</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="setFaultBodyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="setHeaderDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:attribute name="headerName" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of message header to set a new value</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="setOutHeaderDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:attribute name="headerName" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of message header to set a new value</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="setPropertyDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:attribute name="propertyName" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of exchange property to set a new value</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="sortDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:attribute name="comparatorRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a reference to lookup for the comparator to use for sorting</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="splitDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:expressionNode">
+                <xs:sequence/>
+                <xs:attribute name="parallelProcessing" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then processing each splitted messages occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only processing the sub messages from the splitter which happens concurrently.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a reference to the AggregationStrategy to be used to assemble the replies from the splitted messages into a single outgoing message from the Splitter. By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="streaming" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">When in streaming mode then the splitter splits the original message on-demand and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first but then we do not know the total size and therefore the link org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first to know the total size and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the link org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as the messages was splitted.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="stopOnException" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the splitter will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="timeout" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a total timeout specified in millis when using parallel processing. If the Splitter hasn't been able to split and process all the sub messages within the given timeframe then the timeout triggers and the Splitter breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="onPrepareRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="shareUnitOfWork" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Splitter will by default not share unit of work between the parent exchange and each splitted exchange. This means each splitted exchange has its own individual unit of work.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="parallelAggregate" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="stopDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="threadPoolProfileDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:optionalIdentifiedDefinition">
+                <xs:sequence>
+                    <xs:element minOccurs="0" name="timeUnit" type="xs:string"/>
+                </xs:sequence>
+                <xs:attribute name="defaultProfile" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether this profile is the default thread pool profile</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="poolSize" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the core pool size</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="maxPoolSize" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the maximum pool size</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="keepAliveTime" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the keep alive time for idle threads in the pool</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="maxQueueSize" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the maximum number of tasks in the work queue. Use -1 or Integer.MAX_VALUE for an unbounded queue</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="allowCoreThreadTimeOut" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether idle core threads is allowed to timeout and therefore can shrink the pool size below the core pool size Is by default false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="rejectedPolicy" type="tns:threadPoolRejectedPolicy">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the handler for tasks which cannot be executed by the thread pool.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="threadsDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To refer to a custom thread pool or use a thread pool profile (as overlay)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="poolSize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the core pool size</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="maxPoolSize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the maximum pool size</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="keepAliveTime" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the keep alive time for idle threads</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="timeUnit" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the keep alive time unit. By default SECONDS is used.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="maxQueueSize" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the maximum number of tasks in the work queue. Use -1 or Integer.MAX_VALUE for an unbounded queue</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="allowCoreThreadTimeOut" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether idle core threads is allowed to timeout and therefore can shrink the pool size below the core pool size Is by default false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="threadName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the thread name to use.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="rejectedPolicy" type="tns:threadPoolRejectedPolicy">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the handler for tasks which cannot be executed by the thread pool.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="callerRunsWhenRejected" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="throttleDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:expressionNode">
+                <xs:sequence/>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the ExecutorService which could be used by throttle definition</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="timePeriodMillis" type="xs:long">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the time period during which the maximum request count is valid for</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="asyncDelayed" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Enables asynchronous delay which means the thread will no block while delaying.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="callerRunsWhenRejected" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="rejectExecution" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether or not throttler throws the ThrottlerRejectedExecutionException when the exchange exceeds the request limit Is by default false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="throwExceptionDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Reference to the exception instance to lookup from the registry to throw</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="toDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:sendDefinition">
+                <xs:sequence/>
+                <xs:attribute name="pattern" type="tns:exchangePattern">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the optional ExchangePattern used to invoke this endpoint</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="transactedDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets a reference to use for lookup the policy in the registry.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="transformDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="tryDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:output">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="unmarshalDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence>
+                    <xs:choice minOccurs="0">
+                        <xs:element ref="tns:avro"/>
+                        <xs:element ref="tns:base64"/>
+                        <xs:element ref="tns:beanio"/>
+                        <xs:element ref="tns:bindy"/>
+                        <xs:element ref="tns:castor"/>
+                        <xs:element ref="tns:crypto"/>
+                        <xs:element ref="tns:csv"/>
+                        <xs:element name="custom" type="tns:customDataFormat"/>
+                        <xs:element ref="tns:flatpack"/>
+                        <xs:element ref="tns:gzip"/>
+                        <xs:element ref="tns:hl7"/>
+                        <xs:element ref="tns:ical"/>
+                        <xs:element ref="tns:jaxb"/>
+                        <xs:element ref="tns:jibx"/>
+                        <xs:element ref="tns:json"/>
+                        <xs:element ref="tns:protobuf"/>
+                        <xs:element ref="tns:rss"/>
+                        <xs:element ref="tns:secureXML"/>
+                        <xs:element ref="tns:serialization"/>
+                        <xs:element ref="tns:soapjaxb"/>
+                        <xs:element ref="tns:string"/>
+                        <xs:element ref="tns:syslog"/>
+                        <xs:element ref="tns:tidyMarkup"/>
+                        <xs:element ref="tns:univocity-csv"/>
+                        <xs:element ref="tns:univocity-fixed"/>
+                        <xs:element ref="tns:univocity-tsv"/>
+                        <xs:element ref="tns:xmlBeans"/>
+                        <xs:element ref="tns:xmljson"/>
+                        <xs:element ref="tns:xmlrpc"/>
+                        <xs:element ref="tns:xstream"/>
+                        <xs:element ref="tns:pgp"/>
+                        <xs:element ref="tns:zip"/>
+                        <xs:element ref="tns:zipFile"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To refer to a custom data format to use as unmarshaller</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="validateDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputExpressionNode">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="whenSkipSendToEndpointDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:whenDefinition">
+                <xs:sequence/>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="wireTapDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence>
+                    <xs:element minOccurs="0" name="body" type="tns:expressionSubElementDefinition"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:setHeader"/>
+                </xs:sequence>
+                <xs:attribute name="uri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Uri of the endpoint to use as wire tap</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Reference of the endpoint to use as wire tap</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="processorRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Reference to a Processor to use for creating a new body as the message to use for wire tapping</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="executorServiceRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Uses a custom thread pool</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="copy" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Uses a copy of the original exchange</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="onPrepareRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="barcodeDataFormat">
+        <xs:complexContent>
+            <xs:extension base="tns:dataFormat">
+                <xs:sequence/>
+                <xs:attribute name="width" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Width of the barcode</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="height" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Height of the barcode</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="imageType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Image type of the barcode such as png</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="barcodeFormat" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Barcode format such as QR-Code</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="dataFormatsDefinition">
+        <xs:sequence>
+            <xs:choice maxOccurs="unbounded" minOccurs="0">
+                <xs:element ref="tns:avro"/>
+                <xs:element ref="tns:barcode"/>
+                <xs:element ref="tns:base64"/>
+                <xs:element ref="tns:beanio"/>
+                <xs:element ref="tns:bindy"/>
+                <xs:element ref="tns:castor"/>
+                <xs:element ref="tns:crypto"/>
+                <xs:element ref="tns:csv"/>
+                <xs:element name="custom" type="tns:customDataFormat"/>
+                <xs:element ref="tns:flatpack"/>
+                <xs:element ref="tns:gzip"/>
+                <xs:element ref="tns:hl7"/>
+                <xs:element ref="tns:ical"/>
+                <xs:element ref="tns:jaxb"/>
+                <xs:element ref="tns:jibx"/>
+                <xs:element ref="tns:json"/>
+                <xs:element ref="tns:protobuf"/>
+                <xs:element ref="tns:rss"/>
+                <xs:element ref="tns:secureXML"/>
+                <xs:element ref="tns:serialization"/>
+                <xs:element ref="tns:soapjaxb"/>
+                <xs:element ref="tns:string"/>
+                <xs:element ref="tns:syslog"/>
+                <xs:element ref="tns:tidyMarkup"/>
+                <xs:element ref="tns:univocity-csv"/>
+                <xs:element ref="tns:univocity-fixed"/>
+                <xs:element ref="tns:univocity-tsv"/>
+                <xs:element ref="tns:xmlBeans"/>
+                <xs:element ref="tns:xmljson"/>
+                <xs:element ref="tns:xmlrpc"/>
+                <xs:element ref="tns:xstream"/>
+                <xs:element ref="tns:pgp"/>
+                <xs:element ref="tns:zip"/>
+                <xs:element ref="tns:zipFile"/>
+            </xs:choice>
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="constantExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="elExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="exchangePropertyExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="groovyExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="headerExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="jxPathExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression">
+                <xs:attribute name="lenient" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Allows to turn lenient on the JXPathContext. When turned on this allows the JXPath expression to evaluate against expressions and message bodies which may be invalid / missing data. This option is by default false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="javaScriptExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="jsonPathExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression">
+                <xs:attribute name="resultType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the class name of the result type (type from output)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="languageExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression">
+                <xs:attribute name="language" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The name of the language to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="methodCallExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression">
+                <xs:attribute name="bean" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Either a reference or a class name of the bean to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="ref" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Reference to bean to lookup in the registry</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="method" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of method to call</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="beanType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Class name of the bean to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="mvelExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType abstract="true" name="namespaceAwareExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="ognlExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="phpExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="pythonExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="refExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="rubyExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="simpleExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression">
+                <xs:attribute name="resultType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the class name of the result type (type from output)</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="spELExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="sqlExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="terserExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="tokenizerExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:expression">
+                <xs:attribute name="token" type="xs:string" use="required">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The (start) token to use as tokenizer for example \n for a new line token</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="endToken" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The end token to use as tokenizer if using start/end token pairs.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="inheritNamespaceTagName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To inherit namepaces from a root/parent tag name</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="headerName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of header to tokenize instead of using the message body.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="regex" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">If the token is a regular expression pattern. The default value is false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="xml" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether the input is XML messages. This option must be set to true if working with XML payloads.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="includeTokens" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to include the tokens in the parts The default value is false</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="group" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To group N parts together for example to split big files into chunks of 1000 lines.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="vtdXmlExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:namespaceAwareExpression"/>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="xmlTokenizerExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:namespaceAwareExpression">
+                <xs:attribute name="headerName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of header to tokenize instead of using the message body.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="mode" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="group" type="xs:int">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To group N parts together</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="xPathExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:namespaceAwareExpression">
+                <xs:attribute name="documentType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of class for document type The default value is org.w3c.dom.Document</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="resultType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the class name of the result type (type from output) The default result type is NodeSet</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="saxon" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to use Saxon.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="factoryRef" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">References to a custom XPathFactory to lookup in the registry</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="objectModel" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The XPath object model to use</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="logNamespaces" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to log namespaces which can assist during trouble shooting</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="headerName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of header to use as input instead of the message body</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="xQueryExpression">
+        <xs:simpleContent>
+            <xs:extension base="tns:namespaceAwareExpression">
+                <xs:attribute name="type" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the class name of the result type (type from output) The default result type is NodeSet</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="headerName" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Name of header to use as input instead of the message body</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:simpleContent>
+    </xs:complexType>
+
+    <xs:complexType name="deleteVerbDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:verbDefinition">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="verbDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:optionalIdentifiedDefinition">
+                <xs:sequence>
+                    <xs:choice minOccurs="0">
+                        <xs:element ref="tns:to"/>
+                        <xs:element ref="tns:route"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:attribute name="method" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">The HTTP verb such as GET or POST</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="uri" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Uri template of this REST service such as /id.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="consumes" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="produces" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="bindingMode" type="tns:restBindingMode">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="enableCORS" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="type" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="outType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="getVerbDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:verbDefinition">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="headVerbDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:verbDefinition">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="postVerbDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:verbDefinition">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="putVerbDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:verbDefinition">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="restBindingDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:noOutputDefinition">
+                <xs:sequence/>
+                <xs:attribute name="consumes" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To define the content type what the REST service consumes (accept as input) such as application/xml or application/json</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="produces" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To define the content type what the REST service produces (uses for output) such as application/xml or application/json</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="bindingMode" type="tns:restBindingMode">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the binding mode to use. The default value is auto</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="type" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the class name to use for binding from input to POJO for the incoming data</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="outType" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the class name to use for binding from POJO to output for the outgoing data</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="enableCORS" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to enable CORS headers in the HTTP response. The default value is false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:anyAttribute namespace="##other" processContents="skip"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="restConfigurationDefinition">
+        <xs:sequence>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="componentProperty" type="tns:restPropertyDefinition"/>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="endpointProperty" type="tns:restPropertyDefinition"/>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="consumerProperty" type="tns:restPropertyDefinition"/>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="dataFormatProperty" type="tns:restPropertyDefinition"/>
+            <xs:element maxOccurs="unbounded" minOccurs="0" name="corsHeaders" type="tns:restPropertyDefinition"/>
+        </xs:sequence>
+        <xs:attribute name="component" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">The Camel Rest component to use for the REST transport such as restlet spark-rest. If no component has been explicit configured then Camel will lookup if there is a Camel component that integrates with the Rest DSL or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found then that is being used.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="scheme" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">The scheme to use for exposing the REST service. Usually http or https is supported. The default value is http</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="host" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">The hostname to use for exposing the REST service.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="port" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">The port number to use for exposing the REST service. Notice if you use servlet component then the port number configured here does not apply as the port number in use is the actual port number the servlet component is using. eg if using Apache Tomcat its the tomcat http port if using Apache Karaf its the HTTP service in Karaf that uses port 8181 by default etc. Though in those situations setting the port number here allows tooling and JMX to know the port number so its recommended to set the port number to the number that the servlet engine uses.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="contextPath" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets a leading context-path the REST services will be using. This can be used when using components such as SERVLET where the deployed web application is deployed using a context-path.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="hostNameResolver" type="tns:restHostNameResolver">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">If no hostname has been explicit configured then this resolver is used to compute the hostname the REST service will be using.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="bindingMode" type="tns:restBindingMode">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Sets the binding mode to use. The default value is auto</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="enableCORS" type="xs:boolean">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Whether to enable CORS headers in the HTTP response. The default value is false.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="jsonDataFormat" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Name of specific json data format to use. By default json-jackson will be used. Important: This option is only for setting a custom name of the data format not to refer to an existing data format instance.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="xmlDataFormat" type="xs:string">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Name of specific XML data format to use. By default jaxb will be used. Important: This option is only for setting a custom name of the data format not to refer to an existing data format instance.</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType name="restPropertyDefinition">
+        <xs:sequence/>
+        <xs:attribute name="key" type="xs:string" use="required">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Property key</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="value" type="xs:string" use="required">
+            <xs:annotation>
+                <xs:documentation xml:lang="en">Property value</xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:complexType name="restDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:optionalIdentifiedDefinition">
+                <xs:sequence>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:verb"/>
+                        <xs:element ref="tns:delete"/>
+                        <xs:element ref="tns:get"/>
+                        <xs:element ref="tns:head"/>
+                        <xs:element ref="tns:post"/>
+                        <xs:element ref="tns:put"/>
+                    </xs:choice>
+                </xs:sequence>
+                <xs:attribute name="path" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Path of the rest service such as /foo</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="consumes" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="produces" type="xs:string">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="bindingMode" type="tns:restBindingMode">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+                <xs:attribute name="enableCORS" type="xs:boolean">
+                    <xs:annotation>
+                        <xs:documentation xml:lang="en">Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.</xs:documentation>
+                    </xs:annotation>
+                </xs:attribute>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="restsDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:optionalIdentifiedDefinition">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:rest"/>
+                </xs:sequence>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelBeanPostProcessor">
+        <xs:sequence/>
+    </xs:complexType>
+
+    <xs:complexType name="camelConsumerTemplateFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelConsumerTemplateFactoryBean">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelContextFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelContextFactoryBean">
+                <xs:sequence>
+                    <xs:element minOccurs="0" ref="tns:properties"/>
+                    <xs:element minOccurs="0" ref="tns:propertyPlaceholder"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" name="package" type="xs:string"/>
+                    <xs:element minOccurs="0" ref="tns:packageScan"/>
+                    <xs:element minOccurs="0" ref="tns:contextScan"/>
+                    <xs:element minOccurs="0" ref="tns:streamCaching"/>
+                    <xs:element minOccurs="0" ref="tns:jmxAgent"/>
+                    <xs:choice maxOccurs="unbounded" minOccurs="0">
+                        <xs:element ref="tns:template"/>
+                        <xs:element ref="tns:consumerTemplate"/>
+                        <xs:element ref="tns:proxy"/>
+                        <xs:element ref="tns:export"/>
+                        <xs:element ref="tns:errorHandler"/>
+                    </xs:choice>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:routeBuilder"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:routeContextRef"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:restContextRef"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:threadPoolProfile"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:threadPool"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:endpoint"/>
+                    <xs:element minOccurs="0" ref="tns:dataFormats"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:redeliveryPolicyProfile"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:onException"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:onCompletion"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:intercept"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:interceptFrom"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:interceptSendToEndpoint"/>
+                    <xs:element minOccurs="0" ref="tns:restConfiguration"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:rest"/>
+                    <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:route"/>
+                </xs:sequence>
+                <xs:attribute name="depends-on" type="xs:string"/>
+                <xs:attribute name="trace" type="xs:string"/>
+                <xs:attribute name="messageHistory" type="xs:string"/>
+                <xs:attribute name="streamCache" type="xs:string"/>
+                <xs:attribute name="delayer" type="xs:string"/>
+                <xs:attribute name="handleFault" type="xs:string"/>
+                <xs:attribute name="errorHandlerRef" type="xs:string"/>
+                <xs:attribute name="autoStartup" type="xs:string"/>
+                <xs:attribute name="shutdownEager" type="xs:string"/>
+                <xs:attribute name="useMDCLogging" type="xs:string"/>
+                <xs:attribute name="useBreadcrumb" type="xs:string"/>
+                <xs:attribute name="allowUseOriginalMessage" type="xs:string"/>
+                <xs:attribute name="runtimeEndpointRegistryEnabled" type="xs:string"/>
+                <xs:attribute name="managementNamePattern" type="xs:string"/>
+                <xs:attribute name="threadNamePattern" type="xs:string"/>
+                <xs:attribute name="shutdownRoute" type="tns:shutdownRoute"/>
+                <xs:attribute name="shutdownRunningTask" type="tns:shutdownRunningTask"/>
+                <xs:attribute name="lazyLoadTypeConverters" type="xs:boolean"/>
+                <xs:attribute name="typeConverterStatisticsEnabled" type="xs:boolean"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelProducerTemplateFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelProducerTemplateFactoryBean">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="errorHandlerDefinition">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence>
+                    <xs:element minOccurs="0" name="redeliveryPolicy" type="tns:camelRedeliveryPolicyFactoryBean"/>
+                </xs:sequence>
+                <xs:attribute name="type" type="tns:errorHandlerType"/>
+                <xs:attribute name="deadLetterUri" type="xs:string"/>
+                <xs:attribute name="deadLetterHandleNewException" type="xs:string"/>
+                <xs:attribute name="level" type="tns:loggingLevel"/>
+                <xs:attribute name="rollbackLoggingLevel" type="tns:loggingLevel"/>
+                <xs:attribute name="logName" type="xs:string"/>
+                <xs:attribute name="useOriginalMessage" type="xs:boolean"/>
+                <xs:attribute name="transactionTemplateRef" type="xs:string"/>
+                <xs:attribute name="transactionManagerRef" type="xs:string"/>
+                <xs:attribute name="onRedeliveryRef" type="xs:string"/>
+                <xs:attribute name="retryWhileRef" type="xs:string"/>
+                <xs:attribute name="redeliveryPolicyRef" type="xs:string"/>
+                <xs:attribute name="executorServiceRef" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelRedeliveryPolicyFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelRedeliveryPolicyFactoryBean">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelThreadPoolFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelThreadPoolFactoryBean">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelEndpointFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractCamelEndpointFactoryBean">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelRestContextFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" ref="tns:rest"/>
+                </xs:sequence>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="camelRouteContextFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:identifiedType">
+                <xs:sequence>
+                    <xs:element maxOccurs="unbounded" ref="tns:route"/>
+                </xs:sequence>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="keyManagersParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractKeyManagersParametersFactoryBean">
+                <xs:sequence>
+                    <xs:element minOccurs="0" name="keyStore" type="tns:keyStoreParametersFactoryBean"/>
+                </xs:sequence>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="keyStoreParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractKeyStoreParametersFactoryBean">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="sslContextClientParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractJsseUtilFactoryBean">
+                <xs:all>
+                    <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
+                    <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
+                    <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
+                    <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
+                </xs:all>
+                <xs:attribute name="sessionTimeout" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="sslContextParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractJsseUtilFactoryBean">
+                <xs:all>
+                    <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
+                    <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
+                    <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
+                    <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
+                    <xs:element minOccurs="0" name="keyManagers" type="tns:keyManagersParametersFactoryBean"/>
+                    <xs:element minOccurs="0" name="trustManagers" type="tns:trustManagersParametersFactoryBean"/>
+                    <xs:element minOccurs="0" name="secureRandom" type="tns:secureRandomParametersFactoryBean"/>
+                    <xs:element minOccurs="0" name="clientParameters" type="tns:sslContextClientParametersFactoryBean"/>
+                    <xs:element minOccurs="0" name="serverParameters" type="tns:sslContextServerParametersFactoryBean"/>
+                </xs:all>
+                <xs:attribute name="sessionTimeout" type="xs:string"/>
+                <xs:attribute name="provider" type="xs:string"/>
+                <xs:attribute name="secureSocketProtocol" type="xs:string"/>
+                <xs:attribute name="certAlias" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="trustManagersParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractTrustManagersParametersFactoryBean">
+                <xs:sequence>
+                    <xs:element minOccurs="0" name="keyStore" type="tns:keyStoreParametersFactoryBean"/>
+                </xs:sequence>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="secureRandomParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractSecureRandomParametersFactoryBean">
+                <xs:sequence/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:complexType name="sslContextServerParametersFactoryBean">
+        <xs:complexContent>
+            <xs:extension base="tns:abstractJsseUtilFactoryBean">
+                <xs:all>
+                    <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
+                    <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
+                    <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
+                    <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
+                </xs:all>
+                <xs:attribute name="sessionTimeout" type="xs:string"/>
+                <xs:attribute name="clientAuthentication" type="xs:string"/>
+            </xs:extension>
+        </xs:complexContent>
+    </xs:complexType>
+
+    <xs:simpleType name="exchangePattern">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="RobustInOnly"/>
+            <xs:enumeration value="InOptionalOut"/>
+            <xs:enumeration value="InOut"/>
+            <xs:enumeration value="RobustOutOnly"/>
+            <xs:enumeration value="OutOptionalIn"/>
+            <xs:enumeration value="OutIn"/>
+            <xs:enumeration value="OutOnly"/>
+            <xs:enumeration value="InOnly"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="loggingLevel">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="WARN"/>
+            <xs:enumeration value="OFF"/>
+            <xs:enumeration value="TRACE"/>
+            <xs:enumeration value="INFO"/>
+            <xs:enumeration value="DEBUG"/>
+            <xs:enumeration value="ERROR"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="threadPoolRejectedPolicy">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="Discard"/>
+            <xs:enumeration value="CallerRuns"/>
+            <xs:enumeration value="Abort"/>
+            <xs:enumeration value="DiscardOldest"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="bindyType">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="KeyValue"/>
+            <xs:enumeration value="Fixed"/>
+            <xs:enumeration value="Csv"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="jsonLibrary">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="XStream"/>
+            <xs:enumeration value="Gson"/>
+            <xs:enumeration value="Jackson"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="onCompletionMode">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="AfterConsumer"/>
+            <xs:enumeration value="BeforeConsumer"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="shutdownRoute">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="Defer"/>
+            <xs:enumeration value="Default"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="shutdownRunningTask">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="CompleteAllTasks"/>
+            <xs:enumeration value="CompleteCurrentTaskOnly"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="restBindingMode">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="auto"/>
+            <xs:enumeration value="xml"/>
+            <xs:enumeration value="json_xml"/>
+            <xs:enumeration value="off"/>
+            <xs:enumeration value="json"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="restHostNameResolver">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="localHostName"/>
+            <xs:enumeration value="localIp"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="errorHandlerType">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="DeadLetterChannel"/>
+            <xs:enumeration value="TransactionErrorHandler"/>
+            <xs:enumeration value="LoggingErrorHandler"/>
+            <xs:enumeration value="NoErrorHandler"/>
+            <xs:enumeration value="DefaultErrorHandler"/>
+        </xs:restriction>
+    </xs:simpleType>
+</xs:schema>
\ No newline at end of file
diff --git a/carbon-gw/features/org.wso2.carbon.gateway.feature/pom.xml b/carbon-gw/features/org.wso2.carbon.gateway.feature/pom.xml
index 6ae6f49..3aaae77 100644
--- a/carbon-gw/features/org.wso2.carbon.gateway.feature/pom.xml
+++ b/carbon-gw/features/org.wso2.carbon.gateway.feature/pom.xml
@@ -16,13 +16,11 @@
   ~ * limitations under the License.
   ~ */
   -->
-<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xmlns="http://maven.apache.org/POM/4.0.0"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>org.wso2.carbon</groupId>
+        <groupId>org.wso2.carbon.gateway</groupId>
         <artifactId>org.wso2.carbon.gateway.parent</artifactId>
         <version>1.0.0-SNAPSHOT</version>
         <relativePath>../../../pom.xml</relativePath>
@@ -38,6 +36,10 @@
     <dependencies>
         <!-- Netty transport should be a feature of its own -->
         <dependency>
+            <groupId>org.wso2.carbon.gateway</groupId>
+            <artifactId>org.wso2.carbon.gateway</artifactId>
+        </dependency>
+        <dependency>
             <groupId>org.wso2.carbon.transport</groupId>
             <artifactId>org.wso2.carbon.transport.http.netty</artifactId>
         </dependency>
@@ -140,7 +142,7 @@
                                     <symbolicName>org.eclipse.osgi.services</symbolicName>
                                     <version>${equinox.osgi.services.version}</version>
                                 </bundle>
-
+                                
                                 <bundle>
                                     <symbolicName>io.netty.common</symbolicName>
                                     <version>${netty.version}</version>
@@ -165,7 +167,7 @@
                                     <symbolicName>io.netty.buffer</symbolicName>
                                     <version>${netty.version}</version>
                                 </bundle>
-
+                                
                                 <bundle>
                                     <symbolicName>disruptor</symbolicName>
                                     <version>${disruptor.version}</version>
@@ -182,7 +184,7 @@
                                     <symbolicName>spring.framework</symbolicName>
                                     <version>${spring.orbit.version}</version>
                                 </bundle>
-
+                                
                                 <bundle>
                                     <symbolicName>slf4j.api</symbolicName>
                                     <version>${slf4j.version}</version>
@@ -191,7 +193,7 @@
                                     <symbolicName>slf4j.log4j12</symbolicName>
                                     <version>${slf4j.version}</version>
                                 </bundle>
-
+                                
                                 <bundle>
                                     <symbolicName>commons-pool</symbolicName>
                                     <version>${commons.pool.version}</version>
diff --git a/pom.xml b/pom.xml
index b99b2d0..d15b0be 100644
--- a/pom.xml
+++ b/pom.xml
@@ -16,9 +16,7 @@
   ~ * limitations under the License.
   ~ */
   -->
-<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xmlns="http://maven.apache.org/POM/4.0.0"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
@@ -27,11 +25,18 @@
         <version>1</version>
     </parent>
 
-    <groupId>org.wso2.carbon</groupId>
+    <groupId>org.wso2.carbon.gateway</groupId>
     <artifactId>org.wso2.carbon.gateway.parent</artifactId>
     <packaging>pom</packaging>
     <version>1.0.0-SNAPSHOT</version>
 
+    <scm>
+        <url>https://github.com/wso2/product-gw.git</url>
+        <developerConnection>scm:git:https://github.com/wso2/product-gw.git</developerConnection>
+        <connection>scm:git:https://github.com/wso2/product-gw.git</connection>
+        <tag>HEAD</tag>
+    </scm>
+
     <repositories>
         <repository>
             <id>wso2-nexus</id>
@@ -67,20 +72,20 @@
             <dependency>
                 <groupId>org.wso2.carbon</groupId>
                 <artifactId>wso2carbon-kernel</artifactId>
-                <version>${carbon.kernel.version}</version>
-                <type>zip</type>
+				<version>${carbon.kernel.version}</version>
+				 <type>zip</type>
             </dependency>
 
             <dependency>
-                <groupId>org.wso2.carbon</groupId>
+                <groupId>org.wso2.carbon.gateway</groupId>
                 <artifactId>org.wso2.carbon.gateway</artifactId>
                 <version>${carbon.gateway.version}</version>
             </dependency>
             <dependency>
-                <groupId>org.wso2.carbon</groupId>
+                <groupId>org.wso2.carbon.gateway</groupId>
                 <artifactId>org.wso2.carbon.gateway.feature</artifactId>
-                <version>${carbon.gateway.version}</version>
-                <type>zip</type>
+				<version>${carbon.gateway.version}</version>
+				 <type>zip</type>
             </dependency>
 
             <dependency>
@@ -174,11 +179,6 @@
                 <artifactId>commons-pool</artifactId>
                 <version>${commons.pool.version}</version>
             </dependency>
-            <dependency>
-                <groupId>xml-apis</groupId>
-                <artifactId>xml-apis</artifactId>
-                <version>${xml-apis-version}</version>
-            </dependency>
         </dependencies>
     </dependencyManagement>
 
@@ -261,7 +261,7 @@
         <maven.findbugsplugin.version>3.0.2</maven.findbugsplugin.version>
 
         <!-- Dependencies -->
-        <carbon.kernel.version>5.0.0-m5</carbon.kernel.version>
+        <carbon.kernel.version>5.0.0-alpha</carbon.kernel.version>
         <carbon.gateway.version>1.0.0-SNAPSHOT</carbon.gateway.version>
         <carbon.gateway.osgi.version>1.0.0.SNAPSHOT</carbon.gateway.osgi.version>
 
@@ -273,15 +273,14 @@
         <camel.version>2.15.2</camel.version>
         <spring.orbit.version>4.1.6.wso2v1</spring.orbit.version>
         <slf4j.version>1.7.5</slf4j.version>
-        <org.wso2.carbon.transport.http.netty.version>1.0.0-SNAPSHOT</org.wso2.carbon.transport.http.netty.version>
-        <org.wso2.carbon.transport.http.netty.osgi.version>1.0.0.SNAPSHOT
-        </org.wso2.carbon.transport.http.netty.osgi.version>
-        <xml-apis-version>1.4.01</xml-apis-version>
+        <org.wso2.carbon.transport.http.netty.version>1.0.0-alpha</org.wso2.carbon.transport.http.netty.version>
+        <org.wso2.carbon.transport.http.netty.osgi.version>1.0.0.alpha</org.wso2.carbon.transport.http.netty.osgi.version>
+
         <osgi.framework.import.version.range>[1.8.0, 2.0.0)</osgi.framework.import.version.range>
         <osgi.service.tracker.import.version.range>[1.5.1, 2.0.0)</osgi.service.tracker.import.version.range>
         <commons.pool.version>1.5.6.wso2v1</commons.pool.version>
         <carbon.p2.plugin.version>1.5.4</carbon.p2.plugin.version>
-        <carbon.feature.plugin.version>2.0.0-m1</carbon.feature.plugin.version>
+        <carbon.feature.plugin.version>2.0.0-alpha</carbon.feature.plugin.version>
     </properties>
 
     <modules>
diff --git a/product/carbon-home/repository/conf/camel/camel-context.xml b/product/carbon-home/repository/conf/camel/camel-context.xml
index b0be1d0..4b597a5 100644
--- a/product/carbon-home/repository/conf/camel/camel-context.xml
+++ b/product/carbon-home/repository/conf/camel/camel-context.xml
@@ -19,32 +19,57 @@
 <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=" http://www.springframework.org/schema/beans
-http://www.springframework.org/schema/beans/spring-beans.xsd
+classpath:org/springframework/beans/factory/xml/spring-beans-4.1.xsd
 http://camel.apache.org/schema/spring
-http://camel.apache.org/schema/spring/camel-spring.xsd">
+classpath:org/wso2/carbon/gateway/xml/camel-spring.xsd">
 
-    <bean id="wso2-gw" class="org.wso2.carbon.gateway.internal.mediation.camel.CamelMediationComponent"/>
+    <bean id="wso2-gw"
+          class="org.wso2.carbon.gateway.internal.mediation.camel.CamelMediationComponent"/>
 
     <camelContext id="wso2-cc" xmlns="http://camel.apache.org/schema/spring">
 
-        <restConfiguration bindingMode="auto" component="wso2-gw" port="9090"/>
-        <rest path="/AccountManagement">
-            <post uri="/account">
-                <to uri="direct:addAccount"/>
-            </post>
-            <get uri="/customers">
-                <to uri="direct:getCustomer"/>
+        <restConfiguration bindingMode="auto" component="wso2-gw" scheme="http" port="9090"/>
+
+        <!--sample rest interfaces -->
+        <rest path="/gw">
+            <get uri="/news">
+                <to uri="direct:getNews"/>
+            </get>
+            <get uri="/news/{id}">
+                <to uri="direct:getNewsById"/>
             </get>
         </rest>
 
+        <!-- sample routes corresponding to the rest interfaces -->
         <route>
-            <from uri="direct:addAccount"/>
-            <to uri="wso2-gw:http://localhost:9000/services/SimpleStockQuoteService"/>
+            <from uri="direct:getNews"/>
+            <to uri="wso2-gw:http://jsonplaceholder.typicode.com/posts"/>
         </route>
         <route>
-            <from uri="direct:getCustomer"/>
-            <to uri="wso2-gw:http://jsonplaceholder.typicode.com/posts"/>
+            <from uri="direct:getNewsById"/>
+            <recipientList>
+                <simple>wso2-gw:http://jsonplaceholder.typicode.com/posts/${header.id}</simple>
+            </recipientList>
         </route>
+
+        <!-- sample routes based on http header (custom header routeId)-->
+        <route id="http-routes">
+            <from uri="wso2-gw:/default"/>
+            <choice>
+                <when>
+                    <simple>${header.routeId} regex 'r1'</simple>
+                    <to uri="wso2-gw:http://localhost:9000/services/SimpleStockQuoteService"/>
+                </when>
+                <when>
+                    <simple>${header.routeId} regex 'r2'</simple>
+                    <to uri="wso2-gw:http://localhost:9002/service/SimpleStockQuoteService"/>
+                </when>
+                <otherwise>
+                    <to uri="wso2-gw:http://localhost:9004/SimpleStockQuoteService"/>
+                </otherwise>
+            </choice>
+        </route>
+
     </camelContext>
 
 </beans>
diff --git a/product/carbon-home/repository/conf/transports/netty-transports.xml b/product/carbon-home/repository/conf/transports/netty-transports.xml
index 6866111..4562059 100644
--- a/product/carbon-home/repository/conf/transports/netty-transports.xml
+++ b/product/carbon-home/repository/conf/transports/netty-transports.xml
@@ -20,27 +20,7 @@
             xsi:schemaLocation="http://wso2.com/schema/netty-transports/config netty-transports.xsd"
             xmlns="http://wso2.com/schema/netty-transports/config">
     <listeners>
-        <!--
-                <listener
-                        id="jaxrs-http"
-                        host="127.0.0.1"
-                        port="7777"
-                        bossThreadPoolSize="2"
-                        workerThreadPoolSize="250"
-                        execHandlerThreadPoolSize="60"/>
 
-                <listener
-                        id="jaxrs-https"
-                        host="127.0.0.1"
-                        port="8888"
-                        bossThreadPoolSize="2"
-                        workerThreadPoolSize="250"
-                        execHandlerThreadPoolSize="60"
-                        scheme="https"
-                        keyStoreFile="repository/resources/security/cert.jks"
-                        keyStorePass="secret"
-                        certPass="secret"/>
-        -->
         <listener
                 id="netty-gw"
                 host="0.0.0.0"
@@ -55,6 +35,25 @@
                 <parameter name="disruptor.eventhandler.count">1</parameter>
             </parameters>
         </listener>
+
+<!--        <listener
+                id="netty-gw-https"
+                host="0.0.0.0"
+                port="9292"
+                bossThreadPoolSize="4"
+                workerThreadPoolSize="8"
+                execHandlerThreadPoolSize="60"
+                scheme="https"
+                keyStoreFile="repository/resources/security/wso2carbon.jks"
+                keyStorePass="wso2carbon"
+                certPass="wso2carbon">
+            <parameters>
+                <parameter name="disruptor.wait.strategy">BUSY_SPIN</parameter>
+                <parameter name="disruptor.buffer.size">1024</parameter>
+                <parameter name="disruptor.count">1</parameter>
+                <parameter name="disruptor.eventhandler.count">1</parameter>
+            </parameters>
+        </listener>-->
     </listeners>
 
     <senders>
diff --git a/product/carbon-home/repository/resources/security/wso2carbon.jks b/product/carbon-home/repository/resources/security/wso2carbon.jks
new file mode 100644
index 0000000..7942c53
Binary files /dev/null and b/product/carbon-home/repository/resources/security/wso2carbon.jks differ
diff --git a/product/carbon.product b/product/carbon.product
index feac0e2..7a4e7b7 100644
--- a/product/carbon.product
+++ b/product/carbon.product
@@ -2,7 +2,7 @@
 <?pde version="3.5"?>
 
 <product name="Carbon Product" uid="carbon.product.id" id="carbon.product" application="carbon.application"
-version="5.0.0.m5" useFeatures="true" includeLaunchers="true">
+version="5.0.0.alpha" useFeatures="true" includeLaunchers="true">
 
    <configIni use="default">
    </configIni>
@@ -14,7 +14,7 @@ version="5.0.0.m5" useFeatures="true" includeLaunchers="true">
    </plugins>
 
    <features>
-      <feature id="org.wso2.carbon.core.runtime" version="5.0.0.m5"/>
+      <feature id="org.wso2.carbon.core.runtime" version="5.0.0.alpha"/>
    </features>
 
   <configurations>
diff --git a/product/pom.xml b/product/pom.xml
index 351aed0..7201f70 100644
--- a/product/pom.xml
+++ b/product/pom.xml
@@ -16,12 +16,11 @@
   ~ * limitations under the License.
   ~ */
   -->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
     <parent>
-        <groupId>org.wso2.carbon</groupId>
+        <groupId>org.wso2.carbon.gateway</groupId>
         <artifactId>org.wso2.carbon.gateway.parent</artifactId>
         <version>1.0.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
@@ -55,7 +54,7 @@
             <type>zip</type>
         </dependency>
         <dependency>
-            <groupId>org.wso2.carbon</groupId>
+            <groupId>org.wso2.carbon.gateway</groupId>
             <artifactId>org.wso2.carbon.gateway.feature</artifactId>
             <version>${carbon.gateway.version}</version>
             <type>zip</type>
@@ -191,9 +190,8 @@
                         <phase>package</phase>
                         <configuration>
                             <tasks>
-                                <replace dir="target/wso2carbon-kernel-${carbon.kernel.version}/repository/components"
-                                         token="false" value="true">
-                                    <include name="**/bundles.info"/>
+                                <replace dir="target/wso2carbon-kernel-${carbon.kernel.version}/repository/components" token="false" value="true">
+                                    <include name="**/bundles.info" />
                                 </replace>
                             </tasks>
                         </configuration>
@@ -206,14 +204,13 @@
                         <phase>install</phase>
                         <configuration>
                             <target>
-                                <delete dir="target/archive-tmp"/>
-                                <delete dir="target/dependency-maven-plugin-markers"/>
-                                <delete dir="target/org.eclipse.equinox.executable-3.5.0.v20110530-7P7NFUFFLWUl76mart"/>
-                                <delete dir="target/p2-repo"/>
-                                &lt;!&ndash; Figure out a way to delete tmp.* files &ndash;&gt;
-                                <delete file="target/tmp"/>
-                                <delete dir="target/wso2carbon-kernel-${carbon.kernel.version}"/>
-                                <delete dir="target/antrun"/>
+                                <delete dir="target/archive-tmp" />
+                                <delete dir="target/dependency-maven-plugin-markers" />
+                                <delete dir="target/org.eclipse.equinox.executable-3.5.0.v20110530-7P7NFUFFLWUl76mart" />
+                                <delete dir="target/p2-repo" />
+                                <delete file="target/tmp" />
+                                <delete dir="target/wso2carbon-kernel-${carbon.kernel.version}" />
+                                <delete dir="target/antrun" />
                             </target>
                         </configuration>
                         <goals>
diff --git a/product/src/assembly/bin.xml b/product/src/assembly/bin.xml
index bb812d3..0562e71 100644
--- a/product/src/assembly/bin.xml
+++ b/product/src/assembly/bin.xml
@@ -26,7 +26,24 @@
     <fileSets>
         <fileSet>
             <directory>target/wso2carbon-kernel-${carbon.kernel.version}</directory>
-            <outputDirectory></outputDirectory>
+            <outputDirectory>.</outputDirectory>
+            <excludes>
+                <exclude>README.txt</exclude>
+                <exclude>LICENSE.txt</exclude>
+                <exclude>release-notes.html</exclude>
+                <exclude>**/*.ipr</exclude>
+                <exclude>**/*.iwr</exclude>
+                <exclude>**/*.eclipse</exclude>
+            </excludes>
+        </fileSet>
+
+        <fileSet>
+            <directory>..</directory>
+            <outputDirectory>.</outputDirectory>
+            <includes>
+                <include>README.md</include>
+                <include>LICENSE</include>
+            </includes>
         </fileSet>
 
         <fileSet>
@@ -44,6 +61,11 @@
             <outputDirectory>repository/conf/osgi</outputDirectory>
             <fileMode>644</fileMode>
         </fileSet>
+        <fileSet>
+            <directory>carbon-home/repository/resources/security</directory>
+            <outputDirectory>repository/resources/security</outputDirectory>
+            <fileMode>644</fileMode>
+        </fileSet>
     </fileSets>
 
     <files>
